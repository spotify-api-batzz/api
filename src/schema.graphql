"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Album`."""
  albums(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Album`."""
    orderBy: [AlbumsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AlbumCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AlbumFilter
  ): AlbumsConnection

  """Reads and enables pagination through a set of `Artist`."""
  artists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Artist`."""
    orderBy: [ArtistsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ArtistCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ArtistFilter
  ): ArtistsConnection

  """Reads and enables pagination through a set of `RecentListen`."""
  recentListens(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `RecentListen`."""
    orderBy: [RecentListensOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RecentListenCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RecentListenFilter
  ): RecentListensConnection

  """Reads and enables pagination through a set of `Song`."""
  songs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Song`."""
    orderBy: [SongsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SongCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SongFilter
  ): SongsConnection

  """Reads and enables pagination through a set of `Thumbnail`."""
  thumbnails(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Thumbnail`."""
    orderBy: [ThumbnailsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ThumbnailCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ThumbnailFilter
  ): ThumbnailsConnection

  """Reads and enables pagination through a set of `TopArtistDatum`."""
  topArtistData(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TopArtistDatum`."""
    orderBy: [TopArtistDataOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TopArtistDatumCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TopArtistDatumFilter
  ): TopArtistDataConnection

  """Reads and enables pagination through a set of `TopArtist`."""
  topArtists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TopArtist`."""
    orderBy: [TopArtistsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TopArtistCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TopArtistFilter
  ): TopArtistsConnection

  """Reads and enables pagination through a set of `TopSongDatum`."""
  topSongData(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TopSongDatum`."""
    orderBy: [TopSongDataOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TopSongDatumCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TopSongDatumFilter
  ): TopSongDataConnection

  """Reads and enables pagination through a set of `TopSong`."""
  topSongs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TopSong`."""
    orderBy: [TopSongsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TopSongCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TopSongFilter
  ): TopSongsConnection

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection
  album(id: String!): Album
  artist(id: String!): Artist
  recentListen(id: String!): RecentListen
  song(id: String!): Song
  thumbnail(id: String!): Thumbnail
  topArtistDatum(id: String!): TopArtistDatum
  topArtist(id: String!): TopArtist
  topSongDatum(id: String!): TopSongDatum
  topSong(id: String!): TopSong
  user(id: String!): User

  """Reads a single `Album` using its globally unique `ID`."""
  albumByNodeId(
    """The globally unique `ID` to be used in selecting a single `Album`."""
    nodeId: ID!
  ): Album

  """Reads a single `Artist` using its globally unique `ID`."""
  artistByNodeId(
    """The globally unique `ID` to be used in selecting a single `Artist`."""
    nodeId: ID!
  ): Artist

  """Reads a single `RecentListen` using its globally unique `ID`."""
  recentListenByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `RecentListen`.
    """
    nodeId: ID!
  ): RecentListen

  """Reads a single `Song` using its globally unique `ID`."""
  songByNodeId(
    """The globally unique `ID` to be used in selecting a single `Song`."""
    nodeId: ID!
  ): Song

  """Reads a single `Thumbnail` using its globally unique `ID`."""
  thumbnailByNodeId(
    """The globally unique `ID` to be used in selecting a single `Thumbnail`."""
    nodeId: ID!
  ): Thumbnail

  """Reads a single `TopArtistDatum` using its globally unique `ID`."""
  topArtistDatumByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TopArtistDatum`.
    """
    nodeId: ID!
  ): TopArtistDatum

  """Reads a single `TopArtist` using its globally unique `ID`."""
  topArtistByNodeId(
    """The globally unique `ID` to be used in selecting a single `TopArtist`."""
    nodeId: ID!
  ): TopArtist

  """Reads a single `TopSongDatum` using its globally unique `ID`."""
  topSongDatumByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TopSongDatum`.
    """
    nodeId: ID!
  ): TopSongDatum

  """Reads a single `TopSong` using its globally unique `ID`."""
  topSongByNodeId(
    """The globally unique `ID` to be used in selecting a single `TopSong`."""
    nodeId: ID!
  ): TopSong

  """Reads a single `User` using its globally unique `ID`."""
  userByNodeId(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Album` values."""
type AlbumsConnection {
  """A list of `Album` objects."""
  nodes: [Album]!

  """
  A list of edges which contains the `Album` and cursor to aid in pagination.
  """
  edges: [AlbumsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Album` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AlbumAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Album` for these aggregates."""
    groupBy: [AlbumsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AlbumsHavingInput
  ): [AlbumAggregates!]
}

type Album implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String
  spotifyId: String
  artistId: String
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single `Artist` that is related to this `Album`."""
  artist: Artist

  """Reads and enables pagination through a set of `Song`."""
  songs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Song`."""
    orderBy: [SongsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SongCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SongFilter
  ): SongsConnection!

  """Reads through a `Thumbnail`."""
  thumbnails(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Thumbnail`."""
    orderBy: [ThumbnailsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ThumbnailCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ThumbnailFilter
  ): ThumbnailsConnection!
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

type Artist implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  name: String
  spotifyId: String
  createdAt: Datetime
  updatedAt: Datetime

  """Reads and enables pagination through a set of `TopArtistDatum`."""
  topArtistData(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TopArtistDatum`."""
    orderBy: [TopArtistDataOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TopArtistDatumCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TopArtistDatumFilter
  ): TopArtistDataConnection!

  """Reads and enables pagination through a set of `Song`."""
  songs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Song`."""
    orderBy: [SongsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SongCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SongFilter
  ): SongsConnection!

  """Reads and enables pagination through a set of `Album`."""
  albums(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Album`."""
    orderBy: [AlbumsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AlbumCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AlbumFilter
  ): AlbumsConnection!

  """Reads through a `Thumbnail`."""
  thumbnails(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Thumbnail`."""
    orderBy: [ThumbnailsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ThumbnailCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ThumbnailFilter
  ): ThumbnailsConnection!
}

"""A connection to a list of `TopArtistDatum` values."""
type TopArtistDataConnection {
  """A list of `TopArtistDatum` objects."""
  nodes: [TopArtistDatum]!

  """
  A list of edges which contains the `TopArtistDatum` and cursor to aid in pagination.
  """
  edges: [TopArtistDataEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TopArtistDatum` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TopArtistDatumAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `TopArtistDatum` for these aggregates."""
    groupBy: [TopArtistDataGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TopArtistDataHavingInput
  ): [TopArtistDatumAggregates!]
}

type TopArtistDatum implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  artistId: String
  topArtistId: String
  timePeriod: String
  order: Int
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single `Artist` that is related to this `TopArtistDatum`."""
  artist: Artist

  """Reads a single `TopArtist` that is related to this `TopArtistDatum`."""
  topArtist: TopArtist
}

type TopArtist implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  userId: String
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single `User` that is related to this `TopArtist`."""
  user: User

  """Reads and enables pagination through a set of `TopArtistDatum`."""
  topArtistData(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TopArtistDatum`."""
    orderBy: [TopArtistDataOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TopArtistDatumCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TopArtistDatumFilter
  ): TopArtistDataConnection!
}

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  spotifyId: String
  username: String
  password: String
  createdAt: Datetime
  updatedAt: Datetime

  """Reads and enables pagination through a set of `TopSong`."""
  topSongs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TopSong`."""
    orderBy: [TopSongsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TopSongCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TopSongFilter
  ): TopSongsConnection!

  """Reads and enables pagination through a set of `TopArtist`."""
  topArtists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TopArtist`."""
    orderBy: [TopArtistsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TopArtistCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TopArtistFilter
  ): TopArtistsConnection!

  """Reads and enables pagination through a set of `RecentListen`."""
  recentListens(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `RecentListen`."""
    orderBy: [RecentListensOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RecentListenCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RecentListenFilter
  ): RecentListensConnection!
}

"""A connection to a list of `TopSong` values."""
type TopSongsConnection {
  """A list of `TopSong` objects."""
  nodes: [TopSong]!

  """
  A list of edges which contains the `TopSong` and cursor to aid in pagination.
  """
  edges: [TopSongsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TopSong` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TopSongAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `TopSong` for these aggregates."""
    groupBy: [TopSongsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TopSongsHavingInput
  ): [TopSongAggregates!]
}

type TopSong implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  userId: String
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single `User` that is related to this `TopSong`."""
  user: User

  """Reads and enables pagination through a set of `TopSongDatum`."""
  topSongData(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TopSongDatum`."""
    orderBy: [TopSongDataOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TopSongDatumCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TopSongDatumFilter
  ): TopSongDataConnection!
}

"""A connection to a list of `TopSongDatum` values."""
type TopSongDataConnection {
  """A list of `TopSongDatum` objects."""
  nodes: [TopSongDatum]!

  """
  A list of edges which contains the `TopSongDatum` and cursor to aid in pagination.
  """
  edges: [TopSongDataEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TopSongDatum` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TopSongDatumAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `TopSongDatum` for these aggregates."""
    groupBy: [TopSongDataGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TopSongDataHavingInput
  ): [TopSongDatumAggregates!]
}

type TopSongDatum implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  songId: String
  topSongId: String
  order: Int
  timePeriod: String
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single `Song` that is related to this `TopSongDatum`."""
  song: Song

  """Reads a single `TopSong` that is related to this `TopSongDatum`."""
  topSong: TopSong
}

type Song implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  spotifyId: String
  albumId: String
  artistId: String
  name: String
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single `Album` that is related to this `Song`."""
  album: Album

  """Reads a single `Artist` that is related to this `Song`."""
  artist: Artist

  """Reads and enables pagination through a set of `TopSongDatum`."""
  topSongData(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TopSongDatum`."""
    orderBy: [TopSongDataOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TopSongDatumCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TopSongDatumFilter
  ): TopSongDataConnection!

  """Reads and enables pagination through a set of `RecentListen`."""
  recentListens(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `RecentListen`."""
    orderBy: [RecentListensOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RecentListenCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RecentListenFilter
  ): RecentListensConnection!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Methods to use when ordering `TopSongDatum`."""
enum TopSongDataOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  SONG_ID_ASC
  SONG_ID_DESC
  TOP_SONG_ID_ASC
  TOP_SONG_ID_DESC
  ORDER_ASC
  ORDER_DESC
  TIME_PERIOD_ASC
  TIME_PERIOD_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TopSongDatum` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TopSongDatumCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `songId` field."""
  songId: String

  """Checks for equality with the object’s `topSongId` field."""
  topSongId: String

  """Checks for equality with the object’s `order` field."""
  order: Int

  """Checks for equality with the object’s `timePeriod` field."""
  timePeriod: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""
A filter to be used against `TopSongDatum` object types. All fields are combined with a logical ‘and.’
"""
input TopSongDatumFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `songId` field."""
  songId: StringFilter

  """Filter by the object’s `topSongId` field."""
  topSongId: StringFilter

  """Filter by the object’s `order` field."""
  order: IntFilter

  """Filter by the object’s `timePeriod` field."""
  timePeriod: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `song` relation."""
  song: SongFilter

  """A related `song` exists."""
  songExists: Boolean

  """Filter by the object’s `topSong` relation."""
  topSong: TopSongFilter

  """A related `topSong` exists."""
  topSongExists: Boolean

  """Checks for all expressions in this list."""
  and: [TopSongDatumFilter!]

  """Checks for any expressions in this list."""
  or: [TopSongDatumFilter!]

  """Negates the expression."""
  not: TopSongDatumFilter
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """
  Matches the specified pattern using the SQL standard's definition of a regular expression.
  """
  similarTo: String

  """
  Does not match the specified pattern using the SQL standard's definition of a regular expression.
  """
  notSimilarTo: String
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """Not included in the specified list."""
  notIn: [Datetime!]

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime
}

"""
A filter to be used against `Song` object types. All fields are combined with a logical ‘and.’
"""
input SongFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `spotifyId` field."""
  spotifyId: StringFilter

  """Filter by the object’s `albumId` field."""
  albumId: StringFilter

  """Filter by the object’s `artistId` field."""
  artistId: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `topSongData` relation."""
  topSongData: SongToManyTopSongDatumFilter

  """Some related `topSongData` exist."""
  topSongDataExist: Boolean

  """Filter by the object’s `recentListens` relation."""
  recentListens: SongToManyRecentListenFilter

  """Some related `recentListens` exist."""
  recentListensExist: Boolean

  """Filter by the object’s `album` relation."""
  album: AlbumFilter

  """A related `album` exists."""
  albumExists: Boolean

  """Filter by the object’s `artist` relation."""
  artist: ArtistFilter

  """A related `artist` exists."""
  artistExists: Boolean

  """Checks for all expressions in this list."""
  and: [SongFilter!]

  """Checks for any expressions in this list."""
  or: [SongFilter!]

  """Negates the expression."""
  not: SongFilter
}

"""
A filter to be used against many `TopSongDatum` object types. All fields are combined with a logical ‘and.’
"""
input SongToManyTopSongDatumFilter {
  """
  Every related `TopSongDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TopSongDatumFilter

  """
  Some related `TopSongDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TopSongDatumFilter

  """
  No related `TopSongDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TopSongDatumFilter

  """Aggregates across related `TopSongDatum` match the filter criteria."""
  aggregates: TopSongDatumAggregatesFilter
}

"""A filter to be used against aggregates of `TopSongDatum` object types."""
input TopSongDatumAggregatesFilter {
  """
  A filter that must pass for the relevant `TopSongDatum` object to be included within the aggregate.
  """
  filter: TopSongDatumFilter

  """Sum aggregate over matching `TopSongDatum` objects."""
  sum: TopSongDatumSumAggregateFilter

  """Distinct count aggregate over matching `TopSongDatum` objects."""
  distinctCount: TopSongDatumDistinctCountAggregateFilter

  """Minimum aggregate over matching `TopSongDatum` objects."""
  min: TopSongDatumMinAggregateFilter

  """Maximum aggregate over matching `TopSongDatum` objects."""
  max: TopSongDatumMaxAggregateFilter

  """Mean average aggregate over matching `TopSongDatum` objects."""
  average: TopSongDatumAverageAggregateFilter

  """
  Sample standard deviation aggregate over matching `TopSongDatum` objects.
  """
  stddevSample: TopSongDatumStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `TopSongDatum` objects.
  """
  stddevPopulation: TopSongDatumStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `TopSongDatum` objects."""
  varianceSample: TopSongDatumVarianceSampleAggregateFilter

  """Population variance aggregate over matching `TopSongDatum` objects."""
  variancePopulation: TopSongDatumVariancePopulationAggregateFilter
}

input TopSongDatumSumAggregateFilter {
  order: BigIntFilter
}

"""
A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’
"""
input BigIntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigInt

  """Not equal to the specified value."""
  notEqualTo: BigInt

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt

  """Included in the specified list."""
  in: [BigInt!]

  """Not included in the specified list."""
  notIn: [BigInt!]

  """Less than the specified value."""
  lessThan: BigInt

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt

  """Greater than the specified value."""
  greaterThan: BigInt

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

input TopSongDatumDistinctCountAggregateFilter {
  id: BigIntFilter
  songId: BigIntFilter
  topSongId: BigIntFilter
  order: BigIntFilter
  timePeriod: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

input TopSongDatumMinAggregateFilter {
  order: IntFilter
}

input TopSongDatumMaxAggregateFilter {
  order: IntFilter
}

input TopSongDatumAverageAggregateFilter {
  order: BigFloatFilter
}

"""
A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’
"""
input BigFloatFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigFloat

  """Not equal to the specified value."""
  notEqualTo: BigFloat

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigFloat

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigFloat

  """Included in the specified list."""
  in: [BigFloat!]

  """Not included in the specified list."""
  notIn: [BigFloat!]

  """Less than the specified value."""
  lessThan: BigFloat

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigFloat

  """Greater than the specified value."""
  greaterThan: BigFloat

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigFloat
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

input TopSongDatumStddevSampleAggregateFilter {
  order: BigFloatFilter
}

input TopSongDatumStddevPopulationAggregateFilter {
  order: BigFloatFilter
}

input TopSongDatumVarianceSampleAggregateFilter {
  order: BigFloatFilter
}

input TopSongDatumVariancePopulationAggregateFilter {
  order: BigFloatFilter
}

"""
A filter to be used against many `RecentListen` object types. All fields are combined with a logical ‘and.’
"""
input SongToManyRecentListenFilter {
  """
  Every related `RecentListen` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: RecentListenFilter

  """
  Some related `RecentListen` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: RecentListenFilter

  """
  No related `RecentListen` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: RecentListenFilter

  """Aggregates across related `RecentListen` match the filter criteria."""
  aggregates: RecentListenAggregatesFilter
}

"""
A filter to be used against `RecentListen` object types. All fields are combined with a logical ‘and.’
"""
input RecentListenFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `songId` field."""
  songId: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `playedAt` field."""
  playedAt: DatetimeFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `song` relation."""
  song: SongFilter

  """A related `song` exists."""
  songExists: Boolean

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """A related `user` exists."""
  userExists: Boolean

  """Checks for all expressions in this list."""
  and: [RecentListenFilter!]

  """Checks for any expressions in this list."""
  or: [RecentListenFilter!]

  """Negates the expression."""
  not: RecentListenFilter
}

"""
A filter to be used against `User` object types. All fields are combined with a logical ‘and.’
"""
input UserFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `spotifyId` field."""
  spotifyId: StringFilter

  """Filter by the object’s `username` field."""
  username: StringFilter

  """Filter by the object’s `password` field."""
  password: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `topSongs` relation."""
  topSongs: UserToManyTopSongFilter

  """Some related `topSongs` exist."""
  topSongsExist: Boolean

  """Filter by the object’s `topArtists` relation."""
  topArtists: UserToManyTopArtistFilter

  """Some related `topArtists` exist."""
  topArtistsExist: Boolean

  """Filter by the object’s `recentListens` relation."""
  recentListens: UserToManyRecentListenFilter

  """Some related `recentListens` exist."""
  recentListensExist: Boolean

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Negates the expression."""
  not: UserFilter
}

"""
A filter to be used against many `TopSong` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyTopSongFilter {
  """
  Every related `TopSong` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TopSongFilter

  """
  Some related `TopSong` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TopSongFilter

  """
  No related `TopSong` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TopSongFilter

  """Aggregates across related `TopSong` match the filter criteria."""
  aggregates: TopSongAggregatesFilter
}

"""
A filter to be used against `TopSong` object types. All fields are combined with a logical ‘and.’
"""
input TopSongFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `topSongData` relation."""
  topSongData: TopSongToManyTopSongDatumFilter

  """Some related `topSongData` exist."""
  topSongDataExist: Boolean

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """A related `user` exists."""
  userExists: Boolean

  """Checks for all expressions in this list."""
  and: [TopSongFilter!]

  """Checks for any expressions in this list."""
  or: [TopSongFilter!]

  """Negates the expression."""
  not: TopSongFilter
}

"""
A filter to be used against many `TopSongDatum` object types. All fields are combined with a logical ‘and.’
"""
input TopSongToManyTopSongDatumFilter {
  """
  Every related `TopSongDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TopSongDatumFilter

  """
  Some related `TopSongDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TopSongDatumFilter

  """
  No related `TopSongDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TopSongDatumFilter

  """Aggregates across related `TopSongDatum` match the filter criteria."""
  aggregates: TopSongDatumAggregatesFilter
}

"""A filter to be used against aggregates of `TopSong` object types."""
input TopSongAggregatesFilter {
  """
  A filter that must pass for the relevant `TopSong` object to be included within the aggregate.
  """
  filter: TopSongFilter

  """Distinct count aggregate over matching `TopSong` objects."""
  distinctCount: TopSongDistinctCountAggregateFilter
}

input TopSongDistinctCountAggregateFilter {
  id: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many `TopArtist` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyTopArtistFilter {
  """
  Every related `TopArtist` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TopArtistFilter

  """
  Some related `TopArtist` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TopArtistFilter

  """
  No related `TopArtist` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TopArtistFilter

  """Aggregates across related `TopArtist` match the filter criteria."""
  aggregates: TopArtistAggregatesFilter
}

"""
A filter to be used against `TopArtist` object types. All fields are combined with a logical ‘and.’
"""
input TopArtistFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `topArtistData` relation."""
  topArtistData: TopArtistToManyTopArtistDatumFilter

  """Some related `topArtistData` exist."""
  topArtistDataExist: Boolean

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """A related `user` exists."""
  userExists: Boolean

  """Checks for all expressions in this list."""
  and: [TopArtistFilter!]

  """Checks for any expressions in this list."""
  or: [TopArtistFilter!]

  """Negates the expression."""
  not: TopArtistFilter
}

"""
A filter to be used against many `TopArtistDatum` object types. All fields are combined with a logical ‘and.’
"""
input TopArtistToManyTopArtistDatumFilter {
  """
  Every related `TopArtistDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TopArtistDatumFilter

  """
  Some related `TopArtistDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TopArtistDatumFilter

  """
  No related `TopArtistDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TopArtistDatumFilter

  """Aggregates across related `TopArtistDatum` match the filter criteria."""
  aggregates: TopArtistDatumAggregatesFilter
}

"""
A filter to be used against `TopArtistDatum` object types. All fields are combined with a logical ‘and.’
"""
input TopArtistDatumFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `artistId` field."""
  artistId: StringFilter

  """Filter by the object’s `topArtistId` field."""
  topArtistId: StringFilter

  """Filter by the object’s `timePeriod` field."""
  timePeriod: StringFilter

  """Filter by the object’s `order` field."""
  order: IntFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `artist` relation."""
  artist: ArtistFilter

  """A related `artist` exists."""
  artistExists: Boolean

  """Filter by the object’s `topArtist` relation."""
  topArtist: TopArtistFilter

  """A related `topArtist` exists."""
  topArtistExists: Boolean

  """Checks for all expressions in this list."""
  and: [TopArtistDatumFilter!]

  """Checks for any expressions in this list."""
  or: [TopArtistDatumFilter!]

  """Negates the expression."""
  not: TopArtistDatumFilter
}

"""
A filter to be used against `Artist` object types. All fields are combined with a logical ‘and.’
"""
input ArtistFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `spotifyId` field."""
  spotifyId: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `topArtistData` relation."""
  topArtistData: ArtistToManyTopArtistDatumFilter

  """Some related `topArtistData` exist."""
  topArtistDataExist: Boolean

  """Filter by the object’s `songs` relation."""
  songs: ArtistToManySongFilter

  """Some related `songs` exist."""
  songsExist: Boolean

  """Filter by the object’s `albums` relation."""
  albums: ArtistToManyAlbumFilter

  """Some related `albums` exist."""
  albumsExist: Boolean

  """Checks for all expressions in this list."""
  and: [ArtistFilter!]

  """Checks for any expressions in this list."""
  or: [ArtistFilter!]

  """Negates the expression."""
  not: ArtistFilter

  """Filter by the object’s `thumbnails` polymorphic relation."""
  thumbnails: ArtistToManyThumbnailFilterPoly

  """
  Filter for if the object’s `thumbnails`               polymorphic relation exist.
  """
  thumbnailsExist: Boolean
}

"""
A filter to be used against many `TopArtistDatum` object types. All fields are combined with a logical ‘and.’
"""
input ArtistToManyTopArtistDatumFilter {
  """
  Every related `TopArtistDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TopArtistDatumFilter

  """
  Some related `TopArtistDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TopArtistDatumFilter

  """
  No related `TopArtistDatum` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TopArtistDatumFilter

  """Aggregates across related `TopArtistDatum` match the filter criteria."""
  aggregates: TopArtistDatumAggregatesFilter
}

"""
A filter to be used against aggregates of `TopArtistDatum` object types.
"""
input TopArtistDatumAggregatesFilter {
  """
  A filter that must pass for the relevant `TopArtistDatum` object to be included within the aggregate.
  """
  filter: TopArtistDatumFilter

  """Sum aggregate over matching `TopArtistDatum` objects."""
  sum: TopArtistDatumSumAggregateFilter

  """Distinct count aggregate over matching `TopArtistDatum` objects."""
  distinctCount: TopArtistDatumDistinctCountAggregateFilter

  """Minimum aggregate over matching `TopArtistDatum` objects."""
  min: TopArtistDatumMinAggregateFilter

  """Maximum aggregate over matching `TopArtistDatum` objects."""
  max: TopArtistDatumMaxAggregateFilter

  """Mean average aggregate over matching `TopArtistDatum` objects."""
  average: TopArtistDatumAverageAggregateFilter

  """
  Sample standard deviation aggregate over matching `TopArtistDatum` objects.
  """
  stddevSample: TopArtistDatumStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `TopArtistDatum` objects.
  """
  stddevPopulation: TopArtistDatumStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `TopArtistDatum` objects."""
  varianceSample: TopArtistDatumVarianceSampleAggregateFilter

  """Population variance aggregate over matching `TopArtistDatum` objects."""
  variancePopulation: TopArtistDatumVariancePopulationAggregateFilter
}

input TopArtistDatumSumAggregateFilter {
  order: BigIntFilter
}

input TopArtistDatumDistinctCountAggregateFilter {
  id: BigIntFilter
  artistId: BigIntFilter
  topArtistId: BigIntFilter
  timePeriod: BigIntFilter
  order: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

input TopArtistDatumMinAggregateFilter {
  order: IntFilter
}

input TopArtistDatumMaxAggregateFilter {
  order: IntFilter
}

input TopArtistDatumAverageAggregateFilter {
  order: BigFloatFilter
}

input TopArtistDatumStddevSampleAggregateFilter {
  order: BigFloatFilter
}

input TopArtistDatumStddevPopulationAggregateFilter {
  order: BigFloatFilter
}

input TopArtistDatumVarianceSampleAggregateFilter {
  order: BigFloatFilter
}

input TopArtistDatumVariancePopulationAggregateFilter {
  order: BigFloatFilter
}

"""
A filter to be used against many `Song` object types. All fields are combined with a logical ‘and.’
"""
input ArtistToManySongFilter {
  """
  Every related `Song` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: SongFilter

  """
  Some related `Song` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: SongFilter

  """
  No related `Song` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: SongFilter

  """Aggregates across related `Song` match the filter criteria."""
  aggregates: SongAggregatesFilter
}

"""A filter to be used against aggregates of `Song` object types."""
input SongAggregatesFilter {
  """
  A filter that must pass for the relevant `Song` object to be included within the aggregate.
  """
  filter: SongFilter

  """Distinct count aggregate over matching `Song` objects."""
  distinctCount: SongDistinctCountAggregateFilter
}

input SongDistinctCountAggregateFilter {
  id: BigIntFilter
  spotifyId: BigIntFilter
  albumId: BigIntFilter
  artistId: BigIntFilter
  name: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many `Album` object types. All fields are combined with a logical ‘and.’
"""
input ArtistToManyAlbumFilter {
  """
  Every related `Album` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: AlbumFilter

  """
  Some related `Album` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: AlbumFilter

  """
  No related `Album` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: AlbumFilter

  """Aggregates across related `Album` match the filter criteria."""
  aggregates: AlbumAggregatesFilter
}

"""
A filter to be used against `Album` object types. All fields are combined with a logical ‘and.’
"""
input AlbumFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `spotifyId` field."""
  spotifyId: StringFilter

  """Filter by the object’s `artistId` field."""
  artistId: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `songs` relation."""
  songs: AlbumToManySongFilter

  """Some related `songs` exist."""
  songsExist: Boolean

  """Filter by the object’s `artist` relation."""
  artist: ArtistFilter

  """A related `artist` exists."""
  artistExists: Boolean

  """Checks for all expressions in this list."""
  and: [AlbumFilter!]

  """Checks for any expressions in this list."""
  or: [AlbumFilter!]

  """Negates the expression."""
  not: AlbumFilter

  """Filter by the object’s `thumbnails` polymorphic relation."""
  thumbnails: AlbumToManyThumbnailFilterPoly

  """
  Filter for if the object’s `thumbnails`               polymorphic relation exist.
  """
  thumbnailsExist: Boolean
}

"""
A filter to be used against many `Song` object types. All fields are combined with a logical ‘and.’
"""
input AlbumToManySongFilter {
  """
  Every related `Song` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: SongFilter

  """
  Some related `Song` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: SongFilter

  """
  No related `Song` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: SongFilter

  """Aggregates across related `Song` match the filter criteria."""
  aggregates: SongAggregatesFilter
}

"""
A filter to be used against many `Thumbnail` object
                 through polymorphic types. All fields are combined with a logical ‘and.’
"""
input AlbumToManyThumbnailFilterPoly {
  """
  Every related `Thumbnail` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ThumbnailFilter

  """
  Some related `Thumbnail` matches the filter criteria. All fields are combined with a logical ‘any.’
  """
  some: ThumbnailFilter

  """
  No related `Thumbnail` matches the filter criteria. All fields are combined with a logical ‘none.’
  """
  none: ThumbnailFilter
}

"""
A filter to be used against `Thumbnail` object types. All fields are combined with a logical ‘and.’
"""
input ThumbnailFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `entityType` field."""
  entityType: StringFilter

  """Filter by the object’s `entityId` field."""
  entityId: StringFilter

  """Filter by the object’s `width` field."""
  width: IntFilter

  """Filter by the object’s `height` field."""
  height: IntFilter

  """Filter by the object’s `url` field."""
  url: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Checks for all expressions in this list."""
  and: [ThumbnailFilter!]

  """Checks for any expressions in this list."""
  or: [ThumbnailFilter!]

  """Negates the expression."""
  not: ThumbnailFilter

  """Filter by the object’s `albumAsEntity` polymorphic relation."""
  albumAsEntity: AlbumFilter

  """Filter by the object’s `artistAsEntity` polymorphic relation."""
  artistAsEntity: ArtistFilter
}

"""A filter to be used against aggregates of `Album` object types."""
input AlbumAggregatesFilter {
  """
  A filter that must pass for the relevant `Album` object to be included within the aggregate.
  """
  filter: AlbumFilter

  """Distinct count aggregate over matching `Album` objects."""
  distinctCount: AlbumDistinctCountAggregateFilter
}

input AlbumDistinctCountAggregateFilter {
  id: BigIntFilter
  name: BigIntFilter
  spotifyId: BigIntFilter
  artistId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many `Thumbnail` object
                 through polymorphic types. All fields are combined with a logical ‘and.’
"""
input ArtistToManyThumbnailFilterPoly {
  """
  Every related `Thumbnail` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ThumbnailFilter

  """
  Some related `Thumbnail` matches the filter criteria. All fields are combined with a logical ‘any.’
  """
  some: ThumbnailFilter

  """
  No related `Thumbnail` matches the filter criteria. All fields are combined with a logical ‘none.’
  """
  none: ThumbnailFilter
}

"""A filter to be used against aggregates of `TopArtist` object types."""
input TopArtistAggregatesFilter {
  """
  A filter that must pass for the relevant `TopArtist` object to be included within the aggregate.
  """
  filter: TopArtistFilter

  """Distinct count aggregate over matching `TopArtist` objects."""
  distinctCount: TopArtistDistinctCountAggregateFilter
}

input TopArtistDistinctCountAggregateFilter {
  id: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many `RecentListen` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyRecentListenFilter {
  """
  Every related `RecentListen` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: RecentListenFilter

  """
  Some related `RecentListen` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: RecentListenFilter

  """
  No related `RecentListen` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: RecentListenFilter

  """Aggregates across related `RecentListen` match the filter criteria."""
  aggregates: RecentListenAggregatesFilter
}

"""A filter to be used against aggregates of `RecentListen` object types."""
input RecentListenAggregatesFilter {
  """
  A filter that must pass for the relevant `RecentListen` object to be included within the aggregate.
  """
  filter: RecentListenFilter

  """Distinct count aggregate over matching `RecentListen` objects."""
  distinctCount: RecentListenDistinctCountAggregateFilter
}

input RecentListenDistinctCountAggregateFilter {
  id: BigIntFilter
  songId: BigIntFilter
  userId: BigIntFilter
  playedAt: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""A connection to a list of `RecentListen` values."""
type RecentListensConnection {
  """A list of `RecentListen` objects."""
  nodes: [RecentListen]!

  """
  A list of edges which contains the `RecentListen` and cursor to aid in pagination.
  """
  edges: [RecentListensEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `RecentListen` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: RecentListenAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `RecentListen` for these aggregates."""
    groupBy: [RecentListensGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: RecentListensHavingInput
  ): [RecentListenAggregates!]
}

type RecentListen implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  songId: String
  userId: String
  playedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single `Song` that is related to this `RecentListen`."""
  song: Song

  """Reads a single `User` that is related to this `RecentListen`."""
  user: User
}

"""A `RecentListen` edge in the connection."""
type RecentListensEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `RecentListen` at the end of the edge."""
  node: RecentListen
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

type RecentListenAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: RecentListenDistinctCountAggregates
}

type RecentListenDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of songId across the matching connection"""
  songId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of playedAt across the matching connection"""
  playedAt: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `RecentListen` for usage during aggregation."""
enum RecentListensGroupBy {
  SONG_ID
  USER_ID
  PLAYED_AT
  PLAYED_AT_TRUNCATED_TO_HOUR
  PLAYED_AT_TRUNCATED_TO_DAY
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `RecentListen` aggregates."""
input RecentListensHavingInput {
  AND: [RecentListensHavingInput!]
  OR: [RecentListensHavingInput!]
  sum: RecentListensHavingSumInput
  distinctCount: RecentListensHavingDistinctCountInput
  min: RecentListensHavingMinInput
  max: RecentListensHavingMaxInput
  average: RecentListensHavingAverageInput
  stddevSample: RecentListensHavingStddevSampleInput
  stddevPopulation: RecentListensHavingStddevPopulationInput
  varianceSample: RecentListensHavingVarianceSampleInput
  variancePopulation: RecentListensHavingVariancePopulationInput
}

input RecentListensHavingSumInput {
  playedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input HavingDatetimeFilter {
  equalTo: Datetime
  notEqualTo: Datetime
  greaterThan: Datetime
  greaterThanOrEqualTo: Datetime
  lessThan: Datetime
  lessThanOrEqualTo: Datetime
}

input RecentListensHavingDistinctCountInput {
  playedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input RecentListensHavingMinInput {
  playedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input RecentListensHavingMaxInput {
  playedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input RecentListensHavingAverageInput {
  playedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input RecentListensHavingStddevSampleInput {
  playedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input RecentListensHavingStddevPopulationInput {
  playedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input RecentListensHavingVarianceSampleInput {
  playedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input RecentListensHavingVariancePopulationInput {
  playedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering `RecentListen`."""
enum RecentListensOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  SONG_ID_ASC
  SONG_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  PLAYED_AT_ASC
  PLAYED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `RecentListen` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input RecentListenCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `songId` field."""
  songId: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `playedAt` field."""
  playedAt: Datetime

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A `TopSongDatum` edge in the connection."""
type TopSongDataEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TopSongDatum` at the end of the edge."""
  node: TopSongDatum
}

type TopSongDatumAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: TopSongDatumSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TopSongDatumDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: TopSongDatumMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: TopSongDatumMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: TopSongDatumAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: TopSongDatumStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: TopSongDatumStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: TopSongDatumVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: TopSongDatumVariancePopulationAggregates
}

type TopSongDatumSumAggregates {
  """Sum of order across the matching connection"""
  order: BigInt!
}

type TopSongDatumDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of songId across the matching connection"""
  songId: BigInt

  """Distinct count of topSongId across the matching connection"""
  topSongId: BigInt

  """Distinct count of order across the matching connection"""
  order: BigInt

  """Distinct count of timePeriod across the matching connection"""
  timePeriod: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

type TopSongDatumMinAggregates {
  """Minimum of order across the matching connection"""
  order: Int
}

type TopSongDatumMaxAggregates {
  """Maximum of order across the matching connection"""
  order: Int
}

type TopSongDatumAverageAggregates {
  """Mean average of order across the matching connection"""
  order: BigFloat
}

type TopSongDatumStddevSampleAggregates {
  """Sample standard deviation of order across the matching connection"""
  order: BigFloat
}

type TopSongDatumStddevPopulationAggregates {
  """Population standard deviation of order across the matching connection"""
  order: BigFloat
}

type TopSongDatumVarianceSampleAggregates {
  """Sample variance of order across the matching connection"""
  order: BigFloat
}

type TopSongDatumVariancePopulationAggregates {
  """Population variance of order across the matching connection"""
  order: BigFloat
}

"""Grouping methods for `TopSongDatum` for usage during aggregation."""
enum TopSongDataGroupBy {
  SONG_ID
  TOP_SONG_ID
  ORDER
  TIME_PERIOD
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `TopSongDatum` aggregates."""
input TopSongDataHavingInput {
  AND: [TopSongDataHavingInput!]
  OR: [TopSongDataHavingInput!]
  sum: TopSongDataHavingSumInput
  distinctCount: TopSongDataHavingDistinctCountInput
  min: TopSongDataHavingMinInput
  max: TopSongDataHavingMaxInput
  average: TopSongDataHavingAverageInput
  stddevSample: TopSongDataHavingStddevSampleInput
  stddevPopulation: TopSongDataHavingStddevPopulationInput
  varianceSample: TopSongDataHavingVarianceSampleInput
  variancePopulation: TopSongDataHavingVariancePopulationInput
}

input TopSongDataHavingSumInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input HavingIntFilter {
  equalTo: Int
  notEqualTo: Int
  greaterThan: Int
  greaterThanOrEqualTo: Int
  lessThan: Int
  lessThanOrEqualTo: Int
}

input TopSongDataHavingDistinctCountInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongDataHavingMinInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongDataHavingMaxInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongDataHavingAverageInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongDataHavingStddevSampleInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongDataHavingStddevPopulationInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongDataHavingVarianceSampleInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongDataHavingVariancePopulationInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""A `TopSong` edge in the connection."""
type TopSongsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TopSong` at the end of the edge."""
  node: TopSong
}

type TopSongAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TopSongDistinctCountAggregates
}

type TopSongDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `TopSong` for usage during aggregation."""
enum TopSongsGroupBy {
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `TopSong` aggregates."""
input TopSongsHavingInput {
  AND: [TopSongsHavingInput!]
  OR: [TopSongsHavingInput!]
  sum: TopSongsHavingSumInput
  distinctCount: TopSongsHavingDistinctCountInput
  min: TopSongsHavingMinInput
  max: TopSongsHavingMaxInput
  average: TopSongsHavingAverageInput
  stddevSample: TopSongsHavingStddevSampleInput
  stddevPopulation: TopSongsHavingStddevPopulationInput
  varianceSample: TopSongsHavingVarianceSampleInput
  variancePopulation: TopSongsHavingVariancePopulationInput
}

input TopSongsHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongsHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongsHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongsHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongsHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongsHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongsHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongsHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopSongsHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering `TopSong`."""
enum TopSongsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TOP_SONG_DATA_COUNT_ASC
  TOP_SONG_DATA_COUNT_DESC
  TOP_SONG_DATA_SUM_ID_ASC
  TOP_SONG_DATA_SUM_ID_DESC
  TOP_SONG_DATA_SUM_SONG_ID_ASC
  TOP_SONG_DATA_SUM_SONG_ID_DESC
  TOP_SONG_DATA_SUM_TOP_SONG_ID_ASC
  TOP_SONG_DATA_SUM_TOP_SONG_ID_DESC
  TOP_SONG_DATA_SUM_ORDER_ASC
  TOP_SONG_DATA_SUM_ORDER_DESC
  TOP_SONG_DATA_SUM_TIME_PERIOD_ASC
  TOP_SONG_DATA_SUM_TIME_PERIOD_DESC
  TOP_SONG_DATA_SUM_CREATED_AT_ASC
  TOP_SONG_DATA_SUM_CREATED_AT_DESC
  TOP_SONG_DATA_SUM_UPDATED_AT_ASC
  TOP_SONG_DATA_SUM_UPDATED_AT_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_ID_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_ID_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_SONG_ID_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_SONG_ID_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_TOP_SONG_ID_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_TOP_SONG_ID_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_ORDER_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_ORDER_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_TIME_PERIOD_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_TIME_PERIOD_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_CREATED_AT_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_CREATED_AT_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_UPDATED_AT_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_UPDATED_AT_DESC
  TOP_SONG_DATA_MIN_ID_ASC
  TOP_SONG_DATA_MIN_ID_DESC
  TOP_SONG_DATA_MIN_SONG_ID_ASC
  TOP_SONG_DATA_MIN_SONG_ID_DESC
  TOP_SONG_DATA_MIN_TOP_SONG_ID_ASC
  TOP_SONG_DATA_MIN_TOP_SONG_ID_DESC
  TOP_SONG_DATA_MIN_ORDER_ASC
  TOP_SONG_DATA_MIN_ORDER_DESC
  TOP_SONG_DATA_MIN_TIME_PERIOD_ASC
  TOP_SONG_DATA_MIN_TIME_PERIOD_DESC
  TOP_SONG_DATA_MIN_CREATED_AT_ASC
  TOP_SONG_DATA_MIN_CREATED_AT_DESC
  TOP_SONG_DATA_MIN_UPDATED_AT_ASC
  TOP_SONG_DATA_MIN_UPDATED_AT_DESC
  TOP_SONG_DATA_MAX_ID_ASC
  TOP_SONG_DATA_MAX_ID_DESC
  TOP_SONG_DATA_MAX_SONG_ID_ASC
  TOP_SONG_DATA_MAX_SONG_ID_DESC
  TOP_SONG_DATA_MAX_TOP_SONG_ID_ASC
  TOP_SONG_DATA_MAX_TOP_SONG_ID_DESC
  TOP_SONG_DATA_MAX_ORDER_ASC
  TOP_SONG_DATA_MAX_ORDER_DESC
  TOP_SONG_DATA_MAX_TIME_PERIOD_ASC
  TOP_SONG_DATA_MAX_TIME_PERIOD_DESC
  TOP_SONG_DATA_MAX_CREATED_AT_ASC
  TOP_SONG_DATA_MAX_CREATED_AT_DESC
  TOP_SONG_DATA_MAX_UPDATED_AT_ASC
  TOP_SONG_DATA_MAX_UPDATED_AT_DESC
  TOP_SONG_DATA_AVERAGE_ID_ASC
  TOP_SONG_DATA_AVERAGE_ID_DESC
  TOP_SONG_DATA_AVERAGE_SONG_ID_ASC
  TOP_SONG_DATA_AVERAGE_SONG_ID_DESC
  TOP_SONG_DATA_AVERAGE_TOP_SONG_ID_ASC
  TOP_SONG_DATA_AVERAGE_TOP_SONG_ID_DESC
  TOP_SONG_DATA_AVERAGE_ORDER_ASC
  TOP_SONG_DATA_AVERAGE_ORDER_DESC
  TOP_SONG_DATA_AVERAGE_TIME_PERIOD_ASC
  TOP_SONG_DATA_AVERAGE_TIME_PERIOD_DESC
  TOP_SONG_DATA_AVERAGE_CREATED_AT_ASC
  TOP_SONG_DATA_AVERAGE_CREATED_AT_DESC
  TOP_SONG_DATA_AVERAGE_UPDATED_AT_ASC
  TOP_SONG_DATA_AVERAGE_UPDATED_AT_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_ID_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_ID_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_SONG_ID_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_SONG_ID_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_TOP_SONG_ID_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_TOP_SONG_ID_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_ORDER_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_ORDER_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_TIME_PERIOD_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_TIME_PERIOD_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_CREATED_AT_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_CREATED_AT_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_UPDATED_AT_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_UPDATED_AT_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_ID_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_ID_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_SONG_ID_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_SONG_ID_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_TOP_SONG_ID_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_TOP_SONG_ID_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_ORDER_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_ORDER_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_TIME_PERIOD_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_TIME_PERIOD_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_CREATED_AT_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_CREATED_AT_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_UPDATED_AT_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_UPDATED_AT_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_ID_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_ID_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_SONG_ID_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_SONG_ID_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_TOP_SONG_ID_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_TOP_SONG_ID_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_ORDER_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_ORDER_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_TIME_PERIOD_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_TIME_PERIOD_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_CREATED_AT_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_CREATED_AT_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_UPDATED_AT_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_UPDATED_AT_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_ID_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_ID_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_SONG_ID_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_SONG_ID_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_TOP_SONG_ID_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_TOP_SONG_ID_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_ORDER_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_ORDER_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_TIME_PERIOD_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_TIME_PERIOD_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_CREATED_AT_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_CREATED_AT_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_UPDATED_AT_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_UPDATED_AT_DESC
}

"""
A condition to be used against `TopSong` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TopSongCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `TopArtist` values."""
type TopArtistsConnection {
  """A list of `TopArtist` objects."""
  nodes: [TopArtist]!

  """
  A list of edges which contains the `TopArtist` and cursor to aid in pagination.
  """
  edges: [TopArtistsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TopArtist` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TopArtistAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `TopArtist` for these aggregates."""
    groupBy: [TopArtistsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TopArtistsHavingInput
  ): [TopArtistAggregates!]
}

"""A `TopArtist` edge in the connection."""
type TopArtistsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TopArtist` at the end of the edge."""
  node: TopArtist
}

type TopArtistAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TopArtistDistinctCountAggregates
}

type TopArtistDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `TopArtist` for usage during aggregation."""
enum TopArtistsGroupBy {
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `TopArtist` aggregates."""
input TopArtistsHavingInput {
  AND: [TopArtistsHavingInput!]
  OR: [TopArtistsHavingInput!]
  sum: TopArtistsHavingSumInput
  distinctCount: TopArtistsHavingDistinctCountInput
  min: TopArtistsHavingMinInput
  max: TopArtistsHavingMaxInput
  average: TopArtistsHavingAverageInput
  stddevSample: TopArtistsHavingStddevSampleInput
  stddevPopulation: TopArtistsHavingStddevPopulationInput
  varianceSample: TopArtistsHavingVarianceSampleInput
  variancePopulation: TopArtistsHavingVariancePopulationInput
}

input TopArtistsHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistsHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistsHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistsHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistsHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistsHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistsHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistsHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistsHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering `TopArtist`."""
enum TopArtistsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TOP_ARTIST_DATA_COUNT_ASC
  TOP_ARTIST_DATA_COUNT_DESC
  TOP_ARTIST_DATA_SUM_ID_ASC
  TOP_ARTIST_DATA_SUM_ID_DESC
  TOP_ARTIST_DATA_SUM_ARTIST_ID_ASC
  TOP_ARTIST_DATA_SUM_ARTIST_ID_DESC
  TOP_ARTIST_DATA_SUM_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_SUM_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_SUM_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_SUM_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_SUM_ORDER_ASC
  TOP_ARTIST_DATA_SUM_ORDER_DESC
  TOP_ARTIST_DATA_SUM_CREATED_AT_ASC
  TOP_ARTIST_DATA_SUM_CREATED_AT_DESC
  TOP_ARTIST_DATA_SUM_UPDATED_AT_ASC
  TOP_ARTIST_DATA_SUM_UPDATED_AT_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ID_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ID_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ARTIST_ID_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ARTIST_ID_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ORDER_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ORDER_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_CREATED_AT_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_CREATED_AT_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_UPDATED_AT_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_UPDATED_AT_DESC
  TOP_ARTIST_DATA_MIN_ID_ASC
  TOP_ARTIST_DATA_MIN_ID_DESC
  TOP_ARTIST_DATA_MIN_ARTIST_ID_ASC
  TOP_ARTIST_DATA_MIN_ARTIST_ID_DESC
  TOP_ARTIST_DATA_MIN_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_MIN_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_MIN_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_MIN_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_MIN_ORDER_ASC
  TOP_ARTIST_DATA_MIN_ORDER_DESC
  TOP_ARTIST_DATA_MIN_CREATED_AT_ASC
  TOP_ARTIST_DATA_MIN_CREATED_AT_DESC
  TOP_ARTIST_DATA_MIN_UPDATED_AT_ASC
  TOP_ARTIST_DATA_MIN_UPDATED_AT_DESC
  TOP_ARTIST_DATA_MAX_ID_ASC
  TOP_ARTIST_DATA_MAX_ID_DESC
  TOP_ARTIST_DATA_MAX_ARTIST_ID_ASC
  TOP_ARTIST_DATA_MAX_ARTIST_ID_DESC
  TOP_ARTIST_DATA_MAX_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_MAX_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_MAX_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_MAX_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_MAX_ORDER_ASC
  TOP_ARTIST_DATA_MAX_ORDER_DESC
  TOP_ARTIST_DATA_MAX_CREATED_AT_ASC
  TOP_ARTIST_DATA_MAX_CREATED_AT_DESC
  TOP_ARTIST_DATA_MAX_UPDATED_AT_ASC
  TOP_ARTIST_DATA_MAX_UPDATED_AT_DESC
  TOP_ARTIST_DATA_AVERAGE_ID_ASC
  TOP_ARTIST_DATA_AVERAGE_ID_DESC
  TOP_ARTIST_DATA_AVERAGE_ARTIST_ID_ASC
  TOP_ARTIST_DATA_AVERAGE_ARTIST_ID_DESC
  TOP_ARTIST_DATA_AVERAGE_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_AVERAGE_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_AVERAGE_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_AVERAGE_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_AVERAGE_ORDER_ASC
  TOP_ARTIST_DATA_AVERAGE_ORDER_DESC
  TOP_ARTIST_DATA_AVERAGE_CREATED_AT_ASC
  TOP_ARTIST_DATA_AVERAGE_CREATED_AT_DESC
  TOP_ARTIST_DATA_AVERAGE_UPDATED_AT_ASC
  TOP_ARTIST_DATA_AVERAGE_UPDATED_AT_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ID_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ID_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ARTIST_ID_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ARTIST_ID_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ORDER_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ORDER_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_CREATED_AT_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_CREATED_AT_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_UPDATED_AT_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_UPDATED_AT_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ID_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ID_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ARTIST_ID_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ARTIST_ID_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ORDER_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ORDER_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_CREATED_AT_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_CREATED_AT_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_UPDATED_AT_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_UPDATED_AT_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ARTIST_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ARTIST_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ORDER_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ORDER_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_CREATED_AT_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_CREATED_AT_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_UPDATED_AT_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_UPDATED_AT_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ARTIST_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ARTIST_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ORDER_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ORDER_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_CREATED_AT_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_CREATED_AT_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_UPDATED_AT_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_UPDATED_AT_DESC
}

"""
A condition to be used against `TopArtist` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TopArtistCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `TopArtistDatum`."""
enum TopArtistDataOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ARTIST_ID_ASC
  ARTIST_ID_DESC
  TOP_ARTIST_ID_ASC
  TOP_ARTIST_ID_DESC
  TIME_PERIOD_ASC
  TIME_PERIOD_DESC
  ORDER_ASC
  ORDER_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TopArtistDatum` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TopArtistDatumCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `artistId` field."""
  artistId: String

  """Checks for equality with the object’s `topArtistId` field."""
  topArtistId: String

  """Checks for equality with the object’s `timePeriod` field."""
  timePeriod: String

  """Checks for equality with the object’s `order` field."""
  order: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A `TopArtistDatum` edge in the connection."""
type TopArtistDataEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TopArtistDatum` at the end of the edge."""
  node: TopArtistDatum
}

type TopArtistDatumAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: TopArtistDatumSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TopArtistDatumDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: TopArtistDatumMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: TopArtistDatumMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: TopArtistDatumAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: TopArtistDatumStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: TopArtistDatumStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: TopArtistDatumVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: TopArtistDatumVariancePopulationAggregates
}

type TopArtistDatumSumAggregates {
  """Sum of order across the matching connection"""
  order: BigInt!
}

type TopArtistDatumDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of artistId across the matching connection"""
  artistId: BigInt

  """Distinct count of topArtistId across the matching connection"""
  topArtistId: BigInt

  """Distinct count of timePeriod across the matching connection"""
  timePeriod: BigInt

  """Distinct count of order across the matching connection"""
  order: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

type TopArtistDatumMinAggregates {
  """Minimum of order across the matching connection"""
  order: Int
}

type TopArtistDatumMaxAggregates {
  """Maximum of order across the matching connection"""
  order: Int
}

type TopArtistDatumAverageAggregates {
  """Mean average of order across the matching connection"""
  order: BigFloat
}

type TopArtistDatumStddevSampleAggregates {
  """Sample standard deviation of order across the matching connection"""
  order: BigFloat
}

type TopArtistDatumStddevPopulationAggregates {
  """Population standard deviation of order across the matching connection"""
  order: BigFloat
}

type TopArtistDatumVarianceSampleAggregates {
  """Sample variance of order across the matching connection"""
  order: BigFloat
}

type TopArtistDatumVariancePopulationAggregates {
  """Population variance of order across the matching connection"""
  order: BigFloat
}

"""Grouping methods for `TopArtistDatum` for usage during aggregation."""
enum TopArtistDataGroupBy {
  ARTIST_ID
  TOP_ARTIST_ID
  TIME_PERIOD
  ORDER
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `TopArtistDatum` aggregates."""
input TopArtistDataHavingInput {
  AND: [TopArtistDataHavingInput!]
  OR: [TopArtistDataHavingInput!]
  sum: TopArtistDataHavingSumInput
  distinctCount: TopArtistDataHavingDistinctCountInput
  min: TopArtistDataHavingMinInput
  max: TopArtistDataHavingMaxInput
  average: TopArtistDataHavingAverageInput
  stddevSample: TopArtistDataHavingStddevSampleInput
  stddevPopulation: TopArtistDataHavingStddevPopulationInput
  varianceSample: TopArtistDataHavingVarianceSampleInput
  variancePopulation: TopArtistDataHavingVariancePopulationInput
}

input TopArtistDataHavingSumInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistDataHavingDistinctCountInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistDataHavingMinInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistDataHavingMaxInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistDataHavingAverageInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistDataHavingStddevSampleInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistDataHavingStddevPopulationInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistDataHavingVarianceSampleInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TopArtistDataHavingVariancePopulationInput {
  order: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""A connection to a list of `Song` values."""
type SongsConnection {
  """A list of `Song` objects."""
  nodes: [Song]!

  """
  A list of edges which contains the `Song` and cursor to aid in pagination.
  """
  edges: [SongsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Song` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: SongAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Song` for these aggregates."""
    groupBy: [SongsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: SongsHavingInput
  ): [SongAggregates!]
}

"""A `Song` edge in the connection."""
type SongsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Song` at the end of the edge."""
  node: Song
}

type SongAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: SongDistinctCountAggregates
}

type SongDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of spotifyId across the matching connection"""
  spotifyId: BigInt

  """Distinct count of albumId across the matching connection"""
  albumId: BigInt

  """Distinct count of artistId across the matching connection"""
  artistId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `Song` for usage during aggregation."""
enum SongsGroupBy {
  SPOTIFY_ID
  ALBUM_ID
  ARTIST_ID
  NAME
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `Song` aggregates."""
input SongsHavingInput {
  AND: [SongsHavingInput!]
  OR: [SongsHavingInput!]
  sum: SongsHavingSumInput
  distinctCount: SongsHavingDistinctCountInput
  min: SongsHavingMinInput
  max: SongsHavingMaxInput
  average: SongsHavingAverageInput
  stddevSample: SongsHavingStddevSampleInput
  stddevPopulation: SongsHavingStddevPopulationInput
  varianceSample: SongsHavingVarianceSampleInput
  variancePopulation: SongsHavingVariancePopulationInput
}

input SongsHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input SongsHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input SongsHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input SongsHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input SongsHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input SongsHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input SongsHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input SongsHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input SongsHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering `Song`."""
enum SongsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  SPOTIFY_ID_ASC
  SPOTIFY_ID_DESC
  ALBUM_ID_ASC
  ALBUM_ID_DESC
  ARTIST_ID_ASC
  ARTIST_ID_DESC
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TOP_SONG_DATA_COUNT_ASC
  TOP_SONG_DATA_COUNT_DESC
  TOP_SONG_DATA_SUM_ID_ASC
  TOP_SONG_DATA_SUM_ID_DESC
  TOP_SONG_DATA_SUM_SONG_ID_ASC
  TOP_SONG_DATA_SUM_SONG_ID_DESC
  TOP_SONG_DATA_SUM_TOP_SONG_ID_ASC
  TOP_SONG_DATA_SUM_TOP_SONG_ID_DESC
  TOP_SONG_DATA_SUM_ORDER_ASC
  TOP_SONG_DATA_SUM_ORDER_DESC
  TOP_SONG_DATA_SUM_TIME_PERIOD_ASC
  TOP_SONG_DATA_SUM_TIME_PERIOD_DESC
  TOP_SONG_DATA_SUM_CREATED_AT_ASC
  TOP_SONG_DATA_SUM_CREATED_AT_DESC
  TOP_SONG_DATA_SUM_UPDATED_AT_ASC
  TOP_SONG_DATA_SUM_UPDATED_AT_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_ID_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_ID_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_SONG_ID_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_SONG_ID_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_TOP_SONG_ID_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_TOP_SONG_ID_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_ORDER_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_ORDER_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_TIME_PERIOD_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_TIME_PERIOD_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_CREATED_AT_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_CREATED_AT_DESC
  TOP_SONG_DATA_DISTINCT_COUNT_UPDATED_AT_ASC
  TOP_SONG_DATA_DISTINCT_COUNT_UPDATED_AT_DESC
  TOP_SONG_DATA_MIN_ID_ASC
  TOP_SONG_DATA_MIN_ID_DESC
  TOP_SONG_DATA_MIN_SONG_ID_ASC
  TOP_SONG_DATA_MIN_SONG_ID_DESC
  TOP_SONG_DATA_MIN_TOP_SONG_ID_ASC
  TOP_SONG_DATA_MIN_TOP_SONG_ID_DESC
  TOP_SONG_DATA_MIN_ORDER_ASC
  TOP_SONG_DATA_MIN_ORDER_DESC
  TOP_SONG_DATA_MIN_TIME_PERIOD_ASC
  TOP_SONG_DATA_MIN_TIME_PERIOD_DESC
  TOP_SONG_DATA_MIN_CREATED_AT_ASC
  TOP_SONG_DATA_MIN_CREATED_AT_DESC
  TOP_SONG_DATA_MIN_UPDATED_AT_ASC
  TOP_SONG_DATA_MIN_UPDATED_AT_DESC
  TOP_SONG_DATA_MAX_ID_ASC
  TOP_SONG_DATA_MAX_ID_DESC
  TOP_SONG_DATA_MAX_SONG_ID_ASC
  TOP_SONG_DATA_MAX_SONG_ID_DESC
  TOP_SONG_DATA_MAX_TOP_SONG_ID_ASC
  TOP_SONG_DATA_MAX_TOP_SONG_ID_DESC
  TOP_SONG_DATA_MAX_ORDER_ASC
  TOP_SONG_DATA_MAX_ORDER_DESC
  TOP_SONG_DATA_MAX_TIME_PERIOD_ASC
  TOP_SONG_DATA_MAX_TIME_PERIOD_DESC
  TOP_SONG_DATA_MAX_CREATED_AT_ASC
  TOP_SONG_DATA_MAX_CREATED_AT_DESC
  TOP_SONG_DATA_MAX_UPDATED_AT_ASC
  TOP_SONG_DATA_MAX_UPDATED_AT_DESC
  TOP_SONG_DATA_AVERAGE_ID_ASC
  TOP_SONG_DATA_AVERAGE_ID_DESC
  TOP_SONG_DATA_AVERAGE_SONG_ID_ASC
  TOP_SONG_DATA_AVERAGE_SONG_ID_DESC
  TOP_SONG_DATA_AVERAGE_TOP_SONG_ID_ASC
  TOP_SONG_DATA_AVERAGE_TOP_SONG_ID_DESC
  TOP_SONG_DATA_AVERAGE_ORDER_ASC
  TOP_SONG_DATA_AVERAGE_ORDER_DESC
  TOP_SONG_DATA_AVERAGE_TIME_PERIOD_ASC
  TOP_SONG_DATA_AVERAGE_TIME_PERIOD_DESC
  TOP_SONG_DATA_AVERAGE_CREATED_AT_ASC
  TOP_SONG_DATA_AVERAGE_CREATED_AT_DESC
  TOP_SONG_DATA_AVERAGE_UPDATED_AT_ASC
  TOP_SONG_DATA_AVERAGE_UPDATED_AT_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_ID_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_ID_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_SONG_ID_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_SONG_ID_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_TOP_SONG_ID_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_TOP_SONG_ID_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_ORDER_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_ORDER_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_TIME_PERIOD_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_TIME_PERIOD_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_CREATED_AT_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_CREATED_AT_DESC
  TOP_SONG_DATA_STDDEV_SAMPLE_UPDATED_AT_ASC
  TOP_SONG_DATA_STDDEV_SAMPLE_UPDATED_AT_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_ID_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_ID_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_SONG_ID_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_SONG_ID_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_TOP_SONG_ID_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_TOP_SONG_ID_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_ORDER_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_ORDER_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_TIME_PERIOD_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_TIME_PERIOD_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_CREATED_AT_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_CREATED_AT_DESC
  TOP_SONG_DATA_STDDEV_POPULATION_UPDATED_AT_ASC
  TOP_SONG_DATA_STDDEV_POPULATION_UPDATED_AT_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_ID_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_ID_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_SONG_ID_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_SONG_ID_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_TOP_SONG_ID_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_TOP_SONG_ID_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_ORDER_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_ORDER_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_TIME_PERIOD_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_TIME_PERIOD_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_CREATED_AT_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_CREATED_AT_DESC
  TOP_SONG_DATA_VARIANCE_SAMPLE_UPDATED_AT_ASC
  TOP_SONG_DATA_VARIANCE_SAMPLE_UPDATED_AT_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_ID_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_ID_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_SONG_ID_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_SONG_ID_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_TOP_SONG_ID_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_TOP_SONG_ID_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_ORDER_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_ORDER_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_TIME_PERIOD_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_TIME_PERIOD_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_CREATED_AT_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_CREATED_AT_DESC
  TOP_SONG_DATA_VARIANCE_POPULATION_UPDATED_AT_ASC
  TOP_SONG_DATA_VARIANCE_POPULATION_UPDATED_AT_DESC
  RECENT_LISTENS_COUNT_ASC
  RECENT_LISTENS_COUNT_DESC
  RECENT_LISTENS_SUM_ID_ASC
  RECENT_LISTENS_SUM_ID_DESC
  RECENT_LISTENS_SUM_SONG_ID_ASC
  RECENT_LISTENS_SUM_SONG_ID_DESC
  RECENT_LISTENS_SUM_USER_ID_ASC
  RECENT_LISTENS_SUM_USER_ID_DESC
  RECENT_LISTENS_SUM_PLAYED_AT_ASC
  RECENT_LISTENS_SUM_PLAYED_AT_DESC
  RECENT_LISTENS_SUM_CREATED_AT_ASC
  RECENT_LISTENS_SUM_CREATED_AT_DESC
  RECENT_LISTENS_SUM_UPDATED_AT_ASC
  RECENT_LISTENS_SUM_UPDATED_AT_DESC
  RECENT_LISTENS_DISTINCT_COUNT_ID_ASC
  RECENT_LISTENS_DISTINCT_COUNT_ID_DESC
  RECENT_LISTENS_DISTINCT_COUNT_SONG_ID_ASC
  RECENT_LISTENS_DISTINCT_COUNT_SONG_ID_DESC
  RECENT_LISTENS_DISTINCT_COUNT_USER_ID_ASC
  RECENT_LISTENS_DISTINCT_COUNT_USER_ID_DESC
  RECENT_LISTENS_DISTINCT_COUNT_PLAYED_AT_ASC
  RECENT_LISTENS_DISTINCT_COUNT_PLAYED_AT_DESC
  RECENT_LISTENS_DISTINCT_COUNT_CREATED_AT_ASC
  RECENT_LISTENS_DISTINCT_COUNT_CREATED_AT_DESC
  RECENT_LISTENS_DISTINCT_COUNT_UPDATED_AT_ASC
  RECENT_LISTENS_DISTINCT_COUNT_UPDATED_AT_DESC
  RECENT_LISTENS_MIN_ID_ASC
  RECENT_LISTENS_MIN_ID_DESC
  RECENT_LISTENS_MIN_SONG_ID_ASC
  RECENT_LISTENS_MIN_SONG_ID_DESC
  RECENT_LISTENS_MIN_USER_ID_ASC
  RECENT_LISTENS_MIN_USER_ID_DESC
  RECENT_LISTENS_MIN_PLAYED_AT_ASC
  RECENT_LISTENS_MIN_PLAYED_AT_DESC
  RECENT_LISTENS_MIN_CREATED_AT_ASC
  RECENT_LISTENS_MIN_CREATED_AT_DESC
  RECENT_LISTENS_MIN_UPDATED_AT_ASC
  RECENT_LISTENS_MIN_UPDATED_AT_DESC
  RECENT_LISTENS_MAX_ID_ASC
  RECENT_LISTENS_MAX_ID_DESC
  RECENT_LISTENS_MAX_SONG_ID_ASC
  RECENT_LISTENS_MAX_SONG_ID_DESC
  RECENT_LISTENS_MAX_USER_ID_ASC
  RECENT_LISTENS_MAX_USER_ID_DESC
  RECENT_LISTENS_MAX_PLAYED_AT_ASC
  RECENT_LISTENS_MAX_PLAYED_AT_DESC
  RECENT_LISTENS_MAX_CREATED_AT_ASC
  RECENT_LISTENS_MAX_CREATED_AT_DESC
  RECENT_LISTENS_MAX_UPDATED_AT_ASC
  RECENT_LISTENS_MAX_UPDATED_AT_DESC
  RECENT_LISTENS_AVERAGE_ID_ASC
  RECENT_LISTENS_AVERAGE_ID_DESC
  RECENT_LISTENS_AVERAGE_SONG_ID_ASC
  RECENT_LISTENS_AVERAGE_SONG_ID_DESC
  RECENT_LISTENS_AVERAGE_USER_ID_ASC
  RECENT_LISTENS_AVERAGE_USER_ID_DESC
  RECENT_LISTENS_AVERAGE_PLAYED_AT_ASC
  RECENT_LISTENS_AVERAGE_PLAYED_AT_DESC
  RECENT_LISTENS_AVERAGE_CREATED_AT_ASC
  RECENT_LISTENS_AVERAGE_CREATED_AT_DESC
  RECENT_LISTENS_AVERAGE_UPDATED_AT_ASC
  RECENT_LISTENS_AVERAGE_UPDATED_AT_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_ID_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_ID_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_SONG_ID_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_SONG_ID_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_USER_ID_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_USER_ID_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_PLAYED_AT_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_PLAYED_AT_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_CREATED_AT_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_CREATED_AT_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_UPDATED_AT_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_UPDATED_AT_DESC
  RECENT_LISTENS_STDDEV_POPULATION_ID_ASC
  RECENT_LISTENS_STDDEV_POPULATION_ID_DESC
  RECENT_LISTENS_STDDEV_POPULATION_SONG_ID_ASC
  RECENT_LISTENS_STDDEV_POPULATION_SONG_ID_DESC
  RECENT_LISTENS_STDDEV_POPULATION_USER_ID_ASC
  RECENT_LISTENS_STDDEV_POPULATION_USER_ID_DESC
  RECENT_LISTENS_STDDEV_POPULATION_PLAYED_AT_ASC
  RECENT_LISTENS_STDDEV_POPULATION_PLAYED_AT_DESC
  RECENT_LISTENS_STDDEV_POPULATION_CREATED_AT_ASC
  RECENT_LISTENS_STDDEV_POPULATION_CREATED_AT_DESC
  RECENT_LISTENS_STDDEV_POPULATION_UPDATED_AT_ASC
  RECENT_LISTENS_STDDEV_POPULATION_UPDATED_AT_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_ID_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_ID_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_SONG_ID_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_SONG_ID_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_USER_ID_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_USER_ID_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_PLAYED_AT_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_PLAYED_AT_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_CREATED_AT_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_CREATED_AT_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_UPDATED_AT_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_UPDATED_AT_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_ID_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_ID_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_SONG_ID_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_SONG_ID_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_USER_ID_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_USER_ID_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_PLAYED_AT_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_PLAYED_AT_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_CREATED_AT_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_CREATED_AT_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_UPDATED_AT_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_UPDATED_AT_DESC
}

"""
A condition to be used against `Song` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input SongCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `spotifyId` field."""
  spotifyId: String

  """Checks for equality with the object’s `albumId` field."""
  albumId: String

  """Checks for equality with the object’s `artistId` field."""
  artistId: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `Album`."""
enum AlbumsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  SPOTIFY_ID_ASC
  SPOTIFY_ID_DESC
  ARTIST_ID_ASC
  ARTIST_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SONGS_COUNT_ASC
  SONGS_COUNT_DESC
  SONGS_SUM_ID_ASC
  SONGS_SUM_ID_DESC
  SONGS_SUM_SPOTIFY_ID_ASC
  SONGS_SUM_SPOTIFY_ID_DESC
  SONGS_SUM_ALBUM_ID_ASC
  SONGS_SUM_ALBUM_ID_DESC
  SONGS_SUM_ARTIST_ID_ASC
  SONGS_SUM_ARTIST_ID_DESC
  SONGS_SUM_NAME_ASC
  SONGS_SUM_NAME_DESC
  SONGS_SUM_CREATED_AT_ASC
  SONGS_SUM_CREATED_AT_DESC
  SONGS_SUM_UPDATED_AT_ASC
  SONGS_SUM_UPDATED_AT_DESC
  SONGS_DISTINCT_COUNT_ID_ASC
  SONGS_DISTINCT_COUNT_ID_DESC
  SONGS_DISTINCT_COUNT_SPOTIFY_ID_ASC
  SONGS_DISTINCT_COUNT_SPOTIFY_ID_DESC
  SONGS_DISTINCT_COUNT_ALBUM_ID_ASC
  SONGS_DISTINCT_COUNT_ALBUM_ID_DESC
  SONGS_DISTINCT_COUNT_ARTIST_ID_ASC
  SONGS_DISTINCT_COUNT_ARTIST_ID_DESC
  SONGS_DISTINCT_COUNT_NAME_ASC
  SONGS_DISTINCT_COUNT_NAME_DESC
  SONGS_DISTINCT_COUNT_CREATED_AT_ASC
  SONGS_DISTINCT_COUNT_CREATED_AT_DESC
  SONGS_DISTINCT_COUNT_UPDATED_AT_ASC
  SONGS_DISTINCT_COUNT_UPDATED_AT_DESC
  SONGS_MIN_ID_ASC
  SONGS_MIN_ID_DESC
  SONGS_MIN_SPOTIFY_ID_ASC
  SONGS_MIN_SPOTIFY_ID_DESC
  SONGS_MIN_ALBUM_ID_ASC
  SONGS_MIN_ALBUM_ID_DESC
  SONGS_MIN_ARTIST_ID_ASC
  SONGS_MIN_ARTIST_ID_DESC
  SONGS_MIN_NAME_ASC
  SONGS_MIN_NAME_DESC
  SONGS_MIN_CREATED_AT_ASC
  SONGS_MIN_CREATED_AT_DESC
  SONGS_MIN_UPDATED_AT_ASC
  SONGS_MIN_UPDATED_AT_DESC
  SONGS_MAX_ID_ASC
  SONGS_MAX_ID_DESC
  SONGS_MAX_SPOTIFY_ID_ASC
  SONGS_MAX_SPOTIFY_ID_DESC
  SONGS_MAX_ALBUM_ID_ASC
  SONGS_MAX_ALBUM_ID_DESC
  SONGS_MAX_ARTIST_ID_ASC
  SONGS_MAX_ARTIST_ID_DESC
  SONGS_MAX_NAME_ASC
  SONGS_MAX_NAME_DESC
  SONGS_MAX_CREATED_AT_ASC
  SONGS_MAX_CREATED_AT_DESC
  SONGS_MAX_UPDATED_AT_ASC
  SONGS_MAX_UPDATED_AT_DESC
  SONGS_AVERAGE_ID_ASC
  SONGS_AVERAGE_ID_DESC
  SONGS_AVERAGE_SPOTIFY_ID_ASC
  SONGS_AVERAGE_SPOTIFY_ID_DESC
  SONGS_AVERAGE_ALBUM_ID_ASC
  SONGS_AVERAGE_ALBUM_ID_DESC
  SONGS_AVERAGE_ARTIST_ID_ASC
  SONGS_AVERAGE_ARTIST_ID_DESC
  SONGS_AVERAGE_NAME_ASC
  SONGS_AVERAGE_NAME_DESC
  SONGS_AVERAGE_CREATED_AT_ASC
  SONGS_AVERAGE_CREATED_AT_DESC
  SONGS_AVERAGE_UPDATED_AT_ASC
  SONGS_AVERAGE_UPDATED_AT_DESC
  SONGS_STDDEV_SAMPLE_ID_ASC
  SONGS_STDDEV_SAMPLE_ID_DESC
  SONGS_STDDEV_SAMPLE_SPOTIFY_ID_ASC
  SONGS_STDDEV_SAMPLE_SPOTIFY_ID_DESC
  SONGS_STDDEV_SAMPLE_ALBUM_ID_ASC
  SONGS_STDDEV_SAMPLE_ALBUM_ID_DESC
  SONGS_STDDEV_SAMPLE_ARTIST_ID_ASC
  SONGS_STDDEV_SAMPLE_ARTIST_ID_DESC
  SONGS_STDDEV_SAMPLE_NAME_ASC
  SONGS_STDDEV_SAMPLE_NAME_DESC
  SONGS_STDDEV_SAMPLE_CREATED_AT_ASC
  SONGS_STDDEV_SAMPLE_CREATED_AT_DESC
  SONGS_STDDEV_SAMPLE_UPDATED_AT_ASC
  SONGS_STDDEV_SAMPLE_UPDATED_AT_DESC
  SONGS_STDDEV_POPULATION_ID_ASC
  SONGS_STDDEV_POPULATION_ID_DESC
  SONGS_STDDEV_POPULATION_SPOTIFY_ID_ASC
  SONGS_STDDEV_POPULATION_SPOTIFY_ID_DESC
  SONGS_STDDEV_POPULATION_ALBUM_ID_ASC
  SONGS_STDDEV_POPULATION_ALBUM_ID_DESC
  SONGS_STDDEV_POPULATION_ARTIST_ID_ASC
  SONGS_STDDEV_POPULATION_ARTIST_ID_DESC
  SONGS_STDDEV_POPULATION_NAME_ASC
  SONGS_STDDEV_POPULATION_NAME_DESC
  SONGS_STDDEV_POPULATION_CREATED_AT_ASC
  SONGS_STDDEV_POPULATION_CREATED_AT_DESC
  SONGS_STDDEV_POPULATION_UPDATED_AT_ASC
  SONGS_STDDEV_POPULATION_UPDATED_AT_DESC
  SONGS_VARIANCE_SAMPLE_ID_ASC
  SONGS_VARIANCE_SAMPLE_ID_DESC
  SONGS_VARIANCE_SAMPLE_SPOTIFY_ID_ASC
  SONGS_VARIANCE_SAMPLE_SPOTIFY_ID_DESC
  SONGS_VARIANCE_SAMPLE_ALBUM_ID_ASC
  SONGS_VARIANCE_SAMPLE_ALBUM_ID_DESC
  SONGS_VARIANCE_SAMPLE_ARTIST_ID_ASC
  SONGS_VARIANCE_SAMPLE_ARTIST_ID_DESC
  SONGS_VARIANCE_SAMPLE_NAME_ASC
  SONGS_VARIANCE_SAMPLE_NAME_DESC
  SONGS_VARIANCE_SAMPLE_CREATED_AT_ASC
  SONGS_VARIANCE_SAMPLE_CREATED_AT_DESC
  SONGS_VARIANCE_SAMPLE_UPDATED_AT_ASC
  SONGS_VARIANCE_SAMPLE_UPDATED_AT_DESC
  SONGS_VARIANCE_POPULATION_ID_ASC
  SONGS_VARIANCE_POPULATION_ID_DESC
  SONGS_VARIANCE_POPULATION_SPOTIFY_ID_ASC
  SONGS_VARIANCE_POPULATION_SPOTIFY_ID_DESC
  SONGS_VARIANCE_POPULATION_ALBUM_ID_ASC
  SONGS_VARIANCE_POPULATION_ALBUM_ID_DESC
  SONGS_VARIANCE_POPULATION_ARTIST_ID_ASC
  SONGS_VARIANCE_POPULATION_ARTIST_ID_DESC
  SONGS_VARIANCE_POPULATION_NAME_ASC
  SONGS_VARIANCE_POPULATION_NAME_DESC
  SONGS_VARIANCE_POPULATION_CREATED_AT_ASC
  SONGS_VARIANCE_POPULATION_CREATED_AT_DESC
  SONGS_VARIANCE_POPULATION_UPDATED_AT_ASC
  SONGS_VARIANCE_POPULATION_UPDATED_AT_DESC
}

"""
A condition to be used against `Album` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AlbumCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `spotifyId` field."""
  spotifyId: String

  """Checks for equality with the object’s `artistId` field."""
  artistId: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `Thumbnail` values."""
type ThumbnailsConnection {
  """A list of `Thumbnail` objects."""
  nodes: [Thumbnail]!

  """
  A list of edges which contains the `Thumbnail` and cursor to aid in pagination.
  """
  edges: [ThumbnailsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Thumbnail` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ThumbnailAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Thumbnail` for these aggregates."""
    groupBy: [ThumbnailsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ThumbnailsHavingInput
  ): [ThumbnailAggregates!]
}

type Thumbnail implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!

  """12"""
  entityType: String
  entityId: String
  width: Int
  height: Int
  url: String
  createdAt: Datetime
  updatedAt: Datetime

  """Reads through a `Album`."""
  albumAsEntity: Album

  """Reads through a `Artist`."""
  artistAsEntity: Artist
}

"""A `Thumbnail` edge in the connection."""
type ThumbnailsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Thumbnail` at the end of the edge."""
  node: Thumbnail
}

type ThumbnailAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: ThumbnailSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ThumbnailDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: ThumbnailMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: ThumbnailMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: ThumbnailAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: ThumbnailStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: ThumbnailStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: ThumbnailVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: ThumbnailVariancePopulationAggregates
}

type ThumbnailSumAggregates {
  """Sum of width across the matching connection"""
  width: BigInt!

  """Sum of height across the matching connection"""
  height: BigInt!
}

type ThumbnailDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of entityType across the matching connection"""
  entityType: BigInt

  """Distinct count of entityId across the matching connection"""
  entityId: BigInt

  """Distinct count of width across the matching connection"""
  width: BigInt

  """Distinct count of height across the matching connection"""
  height: BigInt

  """Distinct count of url across the matching connection"""
  url: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

type ThumbnailMinAggregates {
  """Minimum of width across the matching connection"""
  width: Int

  """Minimum of height across the matching connection"""
  height: Int
}

type ThumbnailMaxAggregates {
  """Maximum of width across the matching connection"""
  width: Int

  """Maximum of height across the matching connection"""
  height: Int
}

type ThumbnailAverageAggregates {
  """Mean average of width across the matching connection"""
  width: BigFloat

  """Mean average of height across the matching connection"""
  height: BigFloat
}

type ThumbnailStddevSampleAggregates {
  """Sample standard deviation of width across the matching connection"""
  width: BigFloat

  """Sample standard deviation of height across the matching connection"""
  height: BigFloat
}

type ThumbnailStddevPopulationAggregates {
  """Population standard deviation of width across the matching connection"""
  width: BigFloat

  """Population standard deviation of height across the matching connection"""
  height: BigFloat
}

type ThumbnailVarianceSampleAggregates {
  """Sample variance of width across the matching connection"""
  width: BigFloat

  """Sample variance of height across the matching connection"""
  height: BigFloat
}

type ThumbnailVariancePopulationAggregates {
  """Population variance of width across the matching connection"""
  width: BigFloat

  """Population variance of height across the matching connection"""
  height: BigFloat
}

"""Grouping methods for `Thumbnail` for usage during aggregation."""
enum ThumbnailsGroupBy {
  ENTITY_TYPE
  ENTITY_ID
  WIDTH
  HEIGHT
  URL
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `Thumbnail` aggregates."""
input ThumbnailsHavingInput {
  AND: [ThumbnailsHavingInput!]
  OR: [ThumbnailsHavingInput!]
  sum: ThumbnailsHavingSumInput
  distinctCount: ThumbnailsHavingDistinctCountInput
  min: ThumbnailsHavingMinInput
  max: ThumbnailsHavingMaxInput
  average: ThumbnailsHavingAverageInput
  stddevSample: ThumbnailsHavingStddevSampleInput
  stddevPopulation: ThumbnailsHavingStddevPopulationInput
  varianceSample: ThumbnailsHavingVarianceSampleInput
  variancePopulation: ThumbnailsHavingVariancePopulationInput
}

input ThumbnailsHavingSumInput {
  width: HavingIntFilter
  height: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ThumbnailsHavingDistinctCountInput {
  width: HavingIntFilter
  height: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ThumbnailsHavingMinInput {
  width: HavingIntFilter
  height: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ThumbnailsHavingMaxInput {
  width: HavingIntFilter
  height: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ThumbnailsHavingAverageInput {
  width: HavingIntFilter
  height: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ThumbnailsHavingStddevSampleInput {
  width: HavingIntFilter
  height: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ThumbnailsHavingStddevPopulationInput {
  width: HavingIntFilter
  height: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ThumbnailsHavingVarianceSampleInput {
  width: HavingIntFilter
  height: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ThumbnailsHavingVariancePopulationInput {
  width: HavingIntFilter
  height: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering `Thumbnail`."""
enum ThumbnailsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ENTITY_TYPE_ASC
  ENTITY_TYPE_DESC
  ENTITY_ID_ASC
  ENTITY_ID_DESC
  WIDTH_ASC
  WIDTH_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  URL_ASC
  URL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Thumbnail` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ThumbnailCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `entityType` field."""
  entityType: String

  """Checks for equality with the object’s `entityId` field."""
  entityId: String

  """Checks for equality with the object’s `width` field."""
  width: Int

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `url` field."""
  url: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A `Album` edge in the connection."""
type AlbumsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Album` at the end of the edge."""
  node: Album
}

type AlbumAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AlbumDistinctCountAggregates
}

type AlbumDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of spotifyId across the matching connection"""
  spotifyId: BigInt

  """Distinct count of artistId across the matching connection"""
  artistId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `Album` for usage during aggregation."""
enum AlbumsGroupBy {
  NAME
  SPOTIFY_ID
  ARTIST_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `Album` aggregates."""
input AlbumsHavingInput {
  AND: [AlbumsHavingInput!]
  OR: [AlbumsHavingInput!]
  sum: AlbumsHavingSumInput
  distinctCount: AlbumsHavingDistinctCountInput
  min: AlbumsHavingMinInput
  max: AlbumsHavingMaxInput
  average: AlbumsHavingAverageInput
  stddevSample: AlbumsHavingStddevSampleInput
  stddevPopulation: AlbumsHavingStddevPopulationInput
  varianceSample: AlbumsHavingVarianceSampleInput
  variancePopulation: AlbumsHavingVariancePopulationInput
}

input AlbumsHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AlbumsHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AlbumsHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AlbumsHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AlbumsHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AlbumsHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AlbumsHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AlbumsHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AlbumsHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""A connection to a list of `Artist` values."""
type ArtistsConnection {
  """A list of `Artist` objects."""
  nodes: [Artist]!

  """
  A list of edges which contains the `Artist` and cursor to aid in pagination.
  """
  edges: [ArtistsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Artist` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ArtistAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Artist` for these aggregates."""
    groupBy: [ArtistsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ArtistsHavingInput
  ): [ArtistAggregates!]
}

"""A `Artist` edge in the connection."""
type ArtistsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Artist` at the end of the edge."""
  node: Artist
}

type ArtistAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ArtistDistinctCountAggregates
}

type ArtistDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of spotifyId across the matching connection"""
  spotifyId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `Artist` for usage during aggregation."""
enum ArtistsGroupBy {
  NAME
  SPOTIFY_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `Artist` aggregates."""
input ArtistsHavingInput {
  AND: [ArtistsHavingInput!]
  OR: [ArtistsHavingInput!]
  sum: ArtistsHavingSumInput
  distinctCount: ArtistsHavingDistinctCountInput
  min: ArtistsHavingMinInput
  max: ArtistsHavingMaxInput
  average: ArtistsHavingAverageInput
  stddevSample: ArtistsHavingStddevSampleInput
  stddevPopulation: ArtistsHavingStddevPopulationInput
  varianceSample: ArtistsHavingVarianceSampleInput
  variancePopulation: ArtistsHavingVariancePopulationInput
}

input ArtistsHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ArtistsHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ArtistsHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ArtistsHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ArtistsHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ArtistsHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ArtistsHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ArtistsHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ArtistsHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering `Artist`."""
enum ArtistsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  SPOTIFY_ID_ASC
  SPOTIFY_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TOP_ARTIST_DATA_COUNT_ASC
  TOP_ARTIST_DATA_COUNT_DESC
  TOP_ARTIST_DATA_SUM_ID_ASC
  TOP_ARTIST_DATA_SUM_ID_DESC
  TOP_ARTIST_DATA_SUM_ARTIST_ID_ASC
  TOP_ARTIST_DATA_SUM_ARTIST_ID_DESC
  TOP_ARTIST_DATA_SUM_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_SUM_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_SUM_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_SUM_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_SUM_ORDER_ASC
  TOP_ARTIST_DATA_SUM_ORDER_DESC
  TOP_ARTIST_DATA_SUM_CREATED_AT_ASC
  TOP_ARTIST_DATA_SUM_CREATED_AT_DESC
  TOP_ARTIST_DATA_SUM_UPDATED_AT_ASC
  TOP_ARTIST_DATA_SUM_UPDATED_AT_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ID_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ID_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ARTIST_ID_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ARTIST_ID_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ORDER_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_ORDER_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_CREATED_AT_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_CREATED_AT_DESC
  TOP_ARTIST_DATA_DISTINCT_COUNT_UPDATED_AT_ASC
  TOP_ARTIST_DATA_DISTINCT_COUNT_UPDATED_AT_DESC
  TOP_ARTIST_DATA_MIN_ID_ASC
  TOP_ARTIST_DATA_MIN_ID_DESC
  TOP_ARTIST_DATA_MIN_ARTIST_ID_ASC
  TOP_ARTIST_DATA_MIN_ARTIST_ID_DESC
  TOP_ARTIST_DATA_MIN_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_MIN_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_MIN_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_MIN_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_MIN_ORDER_ASC
  TOP_ARTIST_DATA_MIN_ORDER_DESC
  TOP_ARTIST_DATA_MIN_CREATED_AT_ASC
  TOP_ARTIST_DATA_MIN_CREATED_AT_DESC
  TOP_ARTIST_DATA_MIN_UPDATED_AT_ASC
  TOP_ARTIST_DATA_MIN_UPDATED_AT_DESC
  TOP_ARTIST_DATA_MAX_ID_ASC
  TOP_ARTIST_DATA_MAX_ID_DESC
  TOP_ARTIST_DATA_MAX_ARTIST_ID_ASC
  TOP_ARTIST_DATA_MAX_ARTIST_ID_DESC
  TOP_ARTIST_DATA_MAX_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_MAX_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_MAX_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_MAX_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_MAX_ORDER_ASC
  TOP_ARTIST_DATA_MAX_ORDER_DESC
  TOP_ARTIST_DATA_MAX_CREATED_AT_ASC
  TOP_ARTIST_DATA_MAX_CREATED_AT_DESC
  TOP_ARTIST_DATA_MAX_UPDATED_AT_ASC
  TOP_ARTIST_DATA_MAX_UPDATED_AT_DESC
  TOP_ARTIST_DATA_AVERAGE_ID_ASC
  TOP_ARTIST_DATA_AVERAGE_ID_DESC
  TOP_ARTIST_DATA_AVERAGE_ARTIST_ID_ASC
  TOP_ARTIST_DATA_AVERAGE_ARTIST_ID_DESC
  TOP_ARTIST_DATA_AVERAGE_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_AVERAGE_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_AVERAGE_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_AVERAGE_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_AVERAGE_ORDER_ASC
  TOP_ARTIST_DATA_AVERAGE_ORDER_DESC
  TOP_ARTIST_DATA_AVERAGE_CREATED_AT_ASC
  TOP_ARTIST_DATA_AVERAGE_CREATED_AT_DESC
  TOP_ARTIST_DATA_AVERAGE_UPDATED_AT_ASC
  TOP_ARTIST_DATA_AVERAGE_UPDATED_AT_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ID_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ID_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ARTIST_ID_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ARTIST_ID_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ORDER_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_ORDER_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_CREATED_AT_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_CREATED_AT_DESC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_UPDATED_AT_ASC
  TOP_ARTIST_DATA_STDDEV_SAMPLE_UPDATED_AT_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ID_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ID_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ARTIST_ID_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ARTIST_ID_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ORDER_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_ORDER_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_CREATED_AT_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_CREATED_AT_DESC
  TOP_ARTIST_DATA_STDDEV_POPULATION_UPDATED_AT_ASC
  TOP_ARTIST_DATA_STDDEV_POPULATION_UPDATED_AT_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ARTIST_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ARTIST_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ORDER_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_ORDER_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_CREATED_AT_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_CREATED_AT_DESC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_UPDATED_AT_ASC
  TOP_ARTIST_DATA_VARIANCE_SAMPLE_UPDATED_AT_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ARTIST_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ARTIST_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_TOP_ARTIST_ID_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_TOP_ARTIST_ID_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_TIME_PERIOD_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_TIME_PERIOD_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ORDER_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_ORDER_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_CREATED_AT_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_CREATED_AT_DESC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_UPDATED_AT_ASC
  TOP_ARTIST_DATA_VARIANCE_POPULATION_UPDATED_AT_DESC
  SONGS_COUNT_ASC
  SONGS_COUNT_DESC
  SONGS_SUM_ID_ASC
  SONGS_SUM_ID_DESC
  SONGS_SUM_SPOTIFY_ID_ASC
  SONGS_SUM_SPOTIFY_ID_DESC
  SONGS_SUM_ALBUM_ID_ASC
  SONGS_SUM_ALBUM_ID_DESC
  SONGS_SUM_ARTIST_ID_ASC
  SONGS_SUM_ARTIST_ID_DESC
  SONGS_SUM_NAME_ASC
  SONGS_SUM_NAME_DESC
  SONGS_SUM_CREATED_AT_ASC
  SONGS_SUM_CREATED_AT_DESC
  SONGS_SUM_UPDATED_AT_ASC
  SONGS_SUM_UPDATED_AT_DESC
  SONGS_DISTINCT_COUNT_ID_ASC
  SONGS_DISTINCT_COUNT_ID_DESC
  SONGS_DISTINCT_COUNT_SPOTIFY_ID_ASC
  SONGS_DISTINCT_COUNT_SPOTIFY_ID_DESC
  SONGS_DISTINCT_COUNT_ALBUM_ID_ASC
  SONGS_DISTINCT_COUNT_ALBUM_ID_DESC
  SONGS_DISTINCT_COUNT_ARTIST_ID_ASC
  SONGS_DISTINCT_COUNT_ARTIST_ID_DESC
  SONGS_DISTINCT_COUNT_NAME_ASC
  SONGS_DISTINCT_COUNT_NAME_DESC
  SONGS_DISTINCT_COUNT_CREATED_AT_ASC
  SONGS_DISTINCT_COUNT_CREATED_AT_DESC
  SONGS_DISTINCT_COUNT_UPDATED_AT_ASC
  SONGS_DISTINCT_COUNT_UPDATED_AT_DESC
  SONGS_MIN_ID_ASC
  SONGS_MIN_ID_DESC
  SONGS_MIN_SPOTIFY_ID_ASC
  SONGS_MIN_SPOTIFY_ID_DESC
  SONGS_MIN_ALBUM_ID_ASC
  SONGS_MIN_ALBUM_ID_DESC
  SONGS_MIN_ARTIST_ID_ASC
  SONGS_MIN_ARTIST_ID_DESC
  SONGS_MIN_NAME_ASC
  SONGS_MIN_NAME_DESC
  SONGS_MIN_CREATED_AT_ASC
  SONGS_MIN_CREATED_AT_DESC
  SONGS_MIN_UPDATED_AT_ASC
  SONGS_MIN_UPDATED_AT_DESC
  SONGS_MAX_ID_ASC
  SONGS_MAX_ID_DESC
  SONGS_MAX_SPOTIFY_ID_ASC
  SONGS_MAX_SPOTIFY_ID_DESC
  SONGS_MAX_ALBUM_ID_ASC
  SONGS_MAX_ALBUM_ID_DESC
  SONGS_MAX_ARTIST_ID_ASC
  SONGS_MAX_ARTIST_ID_DESC
  SONGS_MAX_NAME_ASC
  SONGS_MAX_NAME_DESC
  SONGS_MAX_CREATED_AT_ASC
  SONGS_MAX_CREATED_AT_DESC
  SONGS_MAX_UPDATED_AT_ASC
  SONGS_MAX_UPDATED_AT_DESC
  SONGS_AVERAGE_ID_ASC
  SONGS_AVERAGE_ID_DESC
  SONGS_AVERAGE_SPOTIFY_ID_ASC
  SONGS_AVERAGE_SPOTIFY_ID_DESC
  SONGS_AVERAGE_ALBUM_ID_ASC
  SONGS_AVERAGE_ALBUM_ID_DESC
  SONGS_AVERAGE_ARTIST_ID_ASC
  SONGS_AVERAGE_ARTIST_ID_DESC
  SONGS_AVERAGE_NAME_ASC
  SONGS_AVERAGE_NAME_DESC
  SONGS_AVERAGE_CREATED_AT_ASC
  SONGS_AVERAGE_CREATED_AT_DESC
  SONGS_AVERAGE_UPDATED_AT_ASC
  SONGS_AVERAGE_UPDATED_AT_DESC
  SONGS_STDDEV_SAMPLE_ID_ASC
  SONGS_STDDEV_SAMPLE_ID_DESC
  SONGS_STDDEV_SAMPLE_SPOTIFY_ID_ASC
  SONGS_STDDEV_SAMPLE_SPOTIFY_ID_DESC
  SONGS_STDDEV_SAMPLE_ALBUM_ID_ASC
  SONGS_STDDEV_SAMPLE_ALBUM_ID_DESC
  SONGS_STDDEV_SAMPLE_ARTIST_ID_ASC
  SONGS_STDDEV_SAMPLE_ARTIST_ID_DESC
  SONGS_STDDEV_SAMPLE_NAME_ASC
  SONGS_STDDEV_SAMPLE_NAME_DESC
  SONGS_STDDEV_SAMPLE_CREATED_AT_ASC
  SONGS_STDDEV_SAMPLE_CREATED_AT_DESC
  SONGS_STDDEV_SAMPLE_UPDATED_AT_ASC
  SONGS_STDDEV_SAMPLE_UPDATED_AT_DESC
  SONGS_STDDEV_POPULATION_ID_ASC
  SONGS_STDDEV_POPULATION_ID_DESC
  SONGS_STDDEV_POPULATION_SPOTIFY_ID_ASC
  SONGS_STDDEV_POPULATION_SPOTIFY_ID_DESC
  SONGS_STDDEV_POPULATION_ALBUM_ID_ASC
  SONGS_STDDEV_POPULATION_ALBUM_ID_DESC
  SONGS_STDDEV_POPULATION_ARTIST_ID_ASC
  SONGS_STDDEV_POPULATION_ARTIST_ID_DESC
  SONGS_STDDEV_POPULATION_NAME_ASC
  SONGS_STDDEV_POPULATION_NAME_DESC
  SONGS_STDDEV_POPULATION_CREATED_AT_ASC
  SONGS_STDDEV_POPULATION_CREATED_AT_DESC
  SONGS_STDDEV_POPULATION_UPDATED_AT_ASC
  SONGS_STDDEV_POPULATION_UPDATED_AT_DESC
  SONGS_VARIANCE_SAMPLE_ID_ASC
  SONGS_VARIANCE_SAMPLE_ID_DESC
  SONGS_VARIANCE_SAMPLE_SPOTIFY_ID_ASC
  SONGS_VARIANCE_SAMPLE_SPOTIFY_ID_DESC
  SONGS_VARIANCE_SAMPLE_ALBUM_ID_ASC
  SONGS_VARIANCE_SAMPLE_ALBUM_ID_DESC
  SONGS_VARIANCE_SAMPLE_ARTIST_ID_ASC
  SONGS_VARIANCE_SAMPLE_ARTIST_ID_DESC
  SONGS_VARIANCE_SAMPLE_NAME_ASC
  SONGS_VARIANCE_SAMPLE_NAME_DESC
  SONGS_VARIANCE_SAMPLE_CREATED_AT_ASC
  SONGS_VARIANCE_SAMPLE_CREATED_AT_DESC
  SONGS_VARIANCE_SAMPLE_UPDATED_AT_ASC
  SONGS_VARIANCE_SAMPLE_UPDATED_AT_DESC
  SONGS_VARIANCE_POPULATION_ID_ASC
  SONGS_VARIANCE_POPULATION_ID_DESC
  SONGS_VARIANCE_POPULATION_SPOTIFY_ID_ASC
  SONGS_VARIANCE_POPULATION_SPOTIFY_ID_DESC
  SONGS_VARIANCE_POPULATION_ALBUM_ID_ASC
  SONGS_VARIANCE_POPULATION_ALBUM_ID_DESC
  SONGS_VARIANCE_POPULATION_ARTIST_ID_ASC
  SONGS_VARIANCE_POPULATION_ARTIST_ID_DESC
  SONGS_VARIANCE_POPULATION_NAME_ASC
  SONGS_VARIANCE_POPULATION_NAME_DESC
  SONGS_VARIANCE_POPULATION_CREATED_AT_ASC
  SONGS_VARIANCE_POPULATION_CREATED_AT_DESC
  SONGS_VARIANCE_POPULATION_UPDATED_AT_ASC
  SONGS_VARIANCE_POPULATION_UPDATED_AT_DESC
  ALBUMS_COUNT_ASC
  ALBUMS_COUNT_DESC
  ALBUMS_SUM_ID_ASC
  ALBUMS_SUM_ID_DESC
  ALBUMS_SUM_NAME_ASC
  ALBUMS_SUM_NAME_DESC
  ALBUMS_SUM_SPOTIFY_ID_ASC
  ALBUMS_SUM_SPOTIFY_ID_DESC
  ALBUMS_SUM_ARTIST_ID_ASC
  ALBUMS_SUM_ARTIST_ID_DESC
  ALBUMS_SUM_CREATED_AT_ASC
  ALBUMS_SUM_CREATED_AT_DESC
  ALBUMS_SUM_UPDATED_AT_ASC
  ALBUMS_SUM_UPDATED_AT_DESC
  ALBUMS_DISTINCT_COUNT_ID_ASC
  ALBUMS_DISTINCT_COUNT_ID_DESC
  ALBUMS_DISTINCT_COUNT_NAME_ASC
  ALBUMS_DISTINCT_COUNT_NAME_DESC
  ALBUMS_DISTINCT_COUNT_SPOTIFY_ID_ASC
  ALBUMS_DISTINCT_COUNT_SPOTIFY_ID_DESC
  ALBUMS_DISTINCT_COUNT_ARTIST_ID_ASC
  ALBUMS_DISTINCT_COUNT_ARTIST_ID_DESC
  ALBUMS_DISTINCT_COUNT_CREATED_AT_ASC
  ALBUMS_DISTINCT_COUNT_CREATED_AT_DESC
  ALBUMS_DISTINCT_COUNT_UPDATED_AT_ASC
  ALBUMS_DISTINCT_COUNT_UPDATED_AT_DESC
  ALBUMS_MIN_ID_ASC
  ALBUMS_MIN_ID_DESC
  ALBUMS_MIN_NAME_ASC
  ALBUMS_MIN_NAME_DESC
  ALBUMS_MIN_SPOTIFY_ID_ASC
  ALBUMS_MIN_SPOTIFY_ID_DESC
  ALBUMS_MIN_ARTIST_ID_ASC
  ALBUMS_MIN_ARTIST_ID_DESC
  ALBUMS_MIN_CREATED_AT_ASC
  ALBUMS_MIN_CREATED_AT_DESC
  ALBUMS_MIN_UPDATED_AT_ASC
  ALBUMS_MIN_UPDATED_AT_DESC
  ALBUMS_MAX_ID_ASC
  ALBUMS_MAX_ID_DESC
  ALBUMS_MAX_NAME_ASC
  ALBUMS_MAX_NAME_DESC
  ALBUMS_MAX_SPOTIFY_ID_ASC
  ALBUMS_MAX_SPOTIFY_ID_DESC
  ALBUMS_MAX_ARTIST_ID_ASC
  ALBUMS_MAX_ARTIST_ID_DESC
  ALBUMS_MAX_CREATED_AT_ASC
  ALBUMS_MAX_CREATED_AT_DESC
  ALBUMS_MAX_UPDATED_AT_ASC
  ALBUMS_MAX_UPDATED_AT_DESC
  ALBUMS_AVERAGE_ID_ASC
  ALBUMS_AVERAGE_ID_DESC
  ALBUMS_AVERAGE_NAME_ASC
  ALBUMS_AVERAGE_NAME_DESC
  ALBUMS_AVERAGE_SPOTIFY_ID_ASC
  ALBUMS_AVERAGE_SPOTIFY_ID_DESC
  ALBUMS_AVERAGE_ARTIST_ID_ASC
  ALBUMS_AVERAGE_ARTIST_ID_DESC
  ALBUMS_AVERAGE_CREATED_AT_ASC
  ALBUMS_AVERAGE_CREATED_AT_DESC
  ALBUMS_AVERAGE_UPDATED_AT_ASC
  ALBUMS_AVERAGE_UPDATED_AT_DESC
  ALBUMS_STDDEV_SAMPLE_ID_ASC
  ALBUMS_STDDEV_SAMPLE_ID_DESC
  ALBUMS_STDDEV_SAMPLE_NAME_ASC
  ALBUMS_STDDEV_SAMPLE_NAME_DESC
  ALBUMS_STDDEV_SAMPLE_SPOTIFY_ID_ASC
  ALBUMS_STDDEV_SAMPLE_SPOTIFY_ID_DESC
  ALBUMS_STDDEV_SAMPLE_ARTIST_ID_ASC
  ALBUMS_STDDEV_SAMPLE_ARTIST_ID_DESC
  ALBUMS_STDDEV_SAMPLE_CREATED_AT_ASC
  ALBUMS_STDDEV_SAMPLE_CREATED_AT_DESC
  ALBUMS_STDDEV_SAMPLE_UPDATED_AT_ASC
  ALBUMS_STDDEV_SAMPLE_UPDATED_AT_DESC
  ALBUMS_STDDEV_POPULATION_ID_ASC
  ALBUMS_STDDEV_POPULATION_ID_DESC
  ALBUMS_STDDEV_POPULATION_NAME_ASC
  ALBUMS_STDDEV_POPULATION_NAME_DESC
  ALBUMS_STDDEV_POPULATION_SPOTIFY_ID_ASC
  ALBUMS_STDDEV_POPULATION_SPOTIFY_ID_DESC
  ALBUMS_STDDEV_POPULATION_ARTIST_ID_ASC
  ALBUMS_STDDEV_POPULATION_ARTIST_ID_DESC
  ALBUMS_STDDEV_POPULATION_CREATED_AT_ASC
  ALBUMS_STDDEV_POPULATION_CREATED_AT_DESC
  ALBUMS_STDDEV_POPULATION_UPDATED_AT_ASC
  ALBUMS_STDDEV_POPULATION_UPDATED_AT_DESC
  ALBUMS_VARIANCE_SAMPLE_ID_ASC
  ALBUMS_VARIANCE_SAMPLE_ID_DESC
  ALBUMS_VARIANCE_SAMPLE_NAME_ASC
  ALBUMS_VARIANCE_SAMPLE_NAME_DESC
  ALBUMS_VARIANCE_SAMPLE_SPOTIFY_ID_ASC
  ALBUMS_VARIANCE_SAMPLE_SPOTIFY_ID_DESC
  ALBUMS_VARIANCE_SAMPLE_ARTIST_ID_ASC
  ALBUMS_VARIANCE_SAMPLE_ARTIST_ID_DESC
  ALBUMS_VARIANCE_SAMPLE_CREATED_AT_ASC
  ALBUMS_VARIANCE_SAMPLE_CREATED_AT_DESC
  ALBUMS_VARIANCE_SAMPLE_UPDATED_AT_ASC
  ALBUMS_VARIANCE_SAMPLE_UPDATED_AT_DESC
  ALBUMS_VARIANCE_POPULATION_ID_ASC
  ALBUMS_VARIANCE_POPULATION_ID_DESC
  ALBUMS_VARIANCE_POPULATION_NAME_ASC
  ALBUMS_VARIANCE_POPULATION_NAME_DESC
  ALBUMS_VARIANCE_POPULATION_SPOTIFY_ID_ASC
  ALBUMS_VARIANCE_POPULATION_SPOTIFY_ID_DESC
  ALBUMS_VARIANCE_POPULATION_ARTIST_ID_ASC
  ALBUMS_VARIANCE_POPULATION_ARTIST_ID_DESC
  ALBUMS_VARIANCE_POPULATION_CREATED_AT_ASC
  ALBUMS_VARIANCE_POPULATION_CREATED_AT_DESC
  ALBUMS_VARIANCE_POPULATION_UPDATED_AT_ASC
  ALBUMS_VARIANCE_POPULATION_UPDATED_AT_DESC
}

"""
A condition to be used against `Artist` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ArtistCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `spotifyId` field."""
  spotifyId: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `User` for these aggregates."""
    groupBy: [UsersGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UsersHavingInput
  ): [UserAggregates!]
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User
}

type UserAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserDistinctCountAggregates
}

type UserDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of spotifyId across the matching connection"""
  spotifyId: BigInt

  """Distinct count of username across the matching connection"""
  username: BigInt

  """Distinct count of password across the matching connection"""
  password: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `User` for usage during aggregation."""
enum UsersGroupBy {
  SPOTIFY_ID
  USERNAME
  PASSWORD
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `User` aggregates."""
input UsersHavingInput {
  AND: [UsersHavingInput!]
  OR: [UsersHavingInput!]
  sum: UsersHavingSumInput
  distinctCount: UsersHavingDistinctCountInput
  min: UsersHavingMinInput
  max: UsersHavingMaxInput
  average: UsersHavingAverageInput
  stddevSample: UsersHavingStddevSampleInput
  stddevPopulation: UsersHavingStddevPopulationInput
  varianceSample: UsersHavingVarianceSampleInput
  variancePopulation: UsersHavingVariancePopulationInput
}

input UsersHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UsersHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UsersHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UsersHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UsersHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UsersHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UsersHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UsersHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UsersHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  SPOTIFY_ID_ASC
  SPOTIFY_ID_DESC
  USERNAME_ASC
  USERNAME_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TOP_SONGS_COUNT_ASC
  TOP_SONGS_COUNT_DESC
  TOP_SONGS_SUM_ID_ASC
  TOP_SONGS_SUM_ID_DESC
  TOP_SONGS_SUM_USER_ID_ASC
  TOP_SONGS_SUM_USER_ID_DESC
  TOP_SONGS_SUM_CREATED_AT_ASC
  TOP_SONGS_SUM_CREATED_AT_DESC
  TOP_SONGS_SUM_UPDATED_AT_ASC
  TOP_SONGS_SUM_UPDATED_AT_DESC
  TOP_SONGS_DISTINCT_COUNT_ID_ASC
  TOP_SONGS_DISTINCT_COUNT_ID_DESC
  TOP_SONGS_DISTINCT_COUNT_USER_ID_ASC
  TOP_SONGS_DISTINCT_COUNT_USER_ID_DESC
  TOP_SONGS_DISTINCT_COUNT_CREATED_AT_ASC
  TOP_SONGS_DISTINCT_COUNT_CREATED_AT_DESC
  TOP_SONGS_DISTINCT_COUNT_UPDATED_AT_ASC
  TOP_SONGS_DISTINCT_COUNT_UPDATED_AT_DESC
  TOP_SONGS_MIN_ID_ASC
  TOP_SONGS_MIN_ID_DESC
  TOP_SONGS_MIN_USER_ID_ASC
  TOP_SONGS_MIN_USER_ID_DESC
  TOP_SONGS_MIN_CREATED_AT_ASC
  TOP_SONGS_MIN_CREATED_AT_DESC
  TOP_SONGS_MIN_UPDATED_AT_ASC
  TOP_SONGS_MIN_UPDATED_AT_DESC
  TOP_SONGS_MAX_ID_ASC
  TOP_SONGS_MAX_ID_DESC
  TOP_SONGS_MAX_USER_ID_ASC
  TOP_SONGS_MAX_USER_ID_DESC
  TOP_SONGS_MAX_CREATED_AT_ASC
  TOP_SONGS_MAX_CREATED_AT_DESC
  TOP_SONGS_MAX_UPDATED_AT_ASC
  TOP_SONGS_MAX_UPDATED_AT_DESC
  TOP_SONGS_AVERAGE_ID_ASC
  TOP_SONGS_AVERAGE_ID_DESC
  TOP_SONGS_AVERAGE_USER_ID_ASC
  TOP_SONGS_AVERAGE_USER_ID_DESC
  TOP_SONGS_AVERAGE_CREATED_AT_ASC
  TOP_SONGS_AVERAGE_CREATED_AT_DESC
  TOP_SONGS_AVERAGE_UPDATED_AT_ASC
  TOP_SONGS_AVERAGE_UPDATED_AT_DESC
  TOP_SONGS_STDDEV_SAMPLE_ID_ASC
  TOP_SONGS_STDDEV_SAMPLE_ID_DESC
  TOP_SONGS_STDDEV_SAMPLE_USER_ID_ASC
  TOP_SONGS_STDDEV_SAMPLE_USER_ID_DESC
  TOP_SONGS_STDDEV_SAMPLE_CREATED_AT_ASC
  TOP_SONGS_STDDEV_SAMPLE_CREATED_AT_DESC
  TOP_SONGS_STDDEV_SAMPLE_UPDATED_AT_ASC
  TOP_SONGS_STDDEV_SAMPLE_UPDATED_AT_DESC
  TOP_SONGS_STDDEV_POPULATION_ID_ASC
  TOP_SONGS_STDDEV_POPULATION_ID_DESC
  TOP_SONGS_STDDEV_POPULATION_USER_ID_ASC
  TOP_SONGS_STDDEV_POPULATION_USER_ID_DESC
  TOP_SONGS_STDDEV_POPULATION_CREATED_AT_ASC
  TOP_SONGS_STDDEV_POPULATION_CREATED_AT_DESC
  TOP_SONGS_STDDEV_POPULATION_UPDATED_AT_ASC
  TOP_SONGS_STDDEV_POPULATION_UPDATED_AT_DESC
  TOP_SONGS_VARIANCE_SAMPLE_ID_ASC
  TOP_SONGS_VARIANCE_SAMPLE_ID_DESC
  TOP_SONGS_VARIANCE_SAMPLE_USER_ID_ASC
  TOP_SONGS_VARIANCE_SAMPLE_USER_ID_DESC
  TOP_SONGS_VARIANCE_SAMPLE_CREATED_AT_ASC
  TOP_SONGS_VARIANCE_SAMPLE_CREATED_AT_DESC
  TOP_SONGS_VARIANCE_SAMPLE_UPDATED_AT_ASC
  TOP_SONGS_VARIANCE_SAMPLE_UPDATED_AT_DESC
  TOP_SONGS_VARIANCE_POPULATION_ID_ASC
  TOP_SONGS_VARIANCE_POPULATION_ID_DESC
  TOP_SONGS_VARIANCE_POPULATION_USER_ID_ASC
  TOP_SONGS_VARIANCE_POPULATION_USER_ID_DESC
  TOP_SONGS_VARIANCE_POPULATION_CREATED_AT_ASC
  TOP_SONGS_VARIANCE_POPULATION_CREATED_AT_DESC
  TOP_SONGS_VARIANCE_POPULATION_UPDATED_AT_ASC
  TOP_SONGS_VARIANCE_POPULATION_UPDATED_AT_DESC
  TOP_ARTISTS_COUNT_ASC
  TOP_ARTISTS_COUNT_DESC
  TOP_ARTISTS_SUM_ID_ASC
  TOP_ARTISTS_SUM_ID_DESC
  TOP_ARTISTS_SUM_USER_ID_ASC
  TOP_ARTISTS_SUM_USER_ID_DESC
  TOP_ARTISTS_SUM_CREATED_AT_ASC
  TOP_ARTISTS_SUM_CREATED_AT_DESC
  TOP_ARTISTS_SUM_UPDATED_AT_ASC
  TOP_ARTISTS_SUM_UPDATED_AT_DESC
  TOP_ARTISTS_DISTINCT_COUNT_ID_ASC
  TOP_ARTISTS_DISTINCT_COUNT_ID_DESC
  TOP_ARTISTS_DISTINCT_COUNT_USER_ID_ASC
  TOP_ARTISTS_DISTINCT_COUNT_USER_ID_DESC
  TOP_ARTISTS_DISTINCT_COUNT_CREATED_AT_ASC
  TOP_ARTISTS_DISTINCT_COUNT_CREATED_AT_DESC
  TOP_ARTISTS_DISTINCT_COUNT_UPDATED_AT_ASC
  TOP_ARTISTS_DISTINCT_COUNT_UPDATED_AT_DESC
  TOP_ARTISTS_MIN_ID_ASC
  TOP_ARTISTS_MIN_ID_DESC
  TOP_ARTISTS_MIN_USER_ID_ASC
  TOP_ARTISTS_MIN_USER_ID_DESC
  TOP_ARTISTS_MIN_CREATED_AT_ASC
  TOP_ARTISTS_MIN_CREATED_AT_DESC
  TOP_ARTISTS_MIN_UPDATED_AT_ASC
  TOP_ARTISTS_MIN_UPDATED_AT_DESC
  TOP_ARTISTS_MAX_ID_ASC
  TOP_ARTISTS_MAX_ID_DESC
  TOP_ARTISTS_MAX_USER_ID_ASC
  TOP_ARTISTS_MAX_USER_ID_DESC
  TOP_ARTISTS_MAX_CREATED_AT_ASC
  TOP_ARTISTS_MAX_CREATED_AT_DESC
  TOP_ARTISTS_MAX_UPDATED_AT_ASC
  TOP_ARTISTS_MAX_UPDATED_AT_DESC
  TOP_ARTISTS_AVERAGE_ID_ASC
  TOP_ARTISTS_AVERAGE_ID_DESC
  TOP_ARTISTS_AVERAGE_USER_ID_ASC
  TOP_ARTISTS_AVERAGE_USER_ID_DESC
  TOP_ARTISTS_AVERAGE_CREATED_AT_ASC
  TOP_ARTISTS_AVERAGE_CREATED_AT_DESC
  TOP_ARTISTS_AVERAGE_UPDATED_AT_ASC
  TOP_ARTISTS_AVERAGE_UPDATED_AT_DESC
  TOP_ARTISTS_STDDEV_SAMPLE_ID_ASC
  TOP_ARTISTS_STDDEV_SAMPLE_ID_DESC
  TOP_ARTISTS_STDDEV_SAMPLE_USER_ID_ASC
  TOP_ARTISTS_STDDEV_SAMPLE_USER_ID_DESC
  TOP_ARTISTS_STDDEV_SAMPLE_CREATED_AT_ASC
  TOP_ARTISTS_STDDEV_SAMPLE_CREATED_AT_DESC
  TOP_ARTISTS_STDDEV_SAMPLE_UPDATED_AT_ASC
  TOP_ARTISTS_STDDEV_SAMPLE_UPDATED_AT_DESC
  TOP_ARTISTS_STDDEV_POPULATION_ID_ASC
  TOP_ARTISTS_STDDEV_POPULATION_ID_DESC
  TOP_ARTISTS_STDDEV_POPULATION_USER_ID_ASC
  TOP_ARTISTS_STDDEV_POPULATION_USER_ID_DESC
  TOP_ARTISTS_STDDEV_POPULATION_CREATED_AT_ASC
  TOP_ARTISTS_STDDEV_POPULATION_CREATED_AT_DESC
  TOP_ARTISTS_STDDEV_POPULATION_UPDATED_AT_ASC
  TOP_ARTISTS_STDDEV_POPULATION_UPDATED_AT_DESC
  TOP_ARTISTS_VARIANCE_SAMPLE_ID_ASC
  TOP_ARTISTS_VARIANCE_SAMPLE_ID_DESC
  TOP_ARTISTS_VARIANCE_SAMPLE_USER_ID_ASC
  TOP_ARTISTS_VARIANCE_SAMPLE_USER_ID_DESC
  TOP_ARTISTS_VARIANCE_SAMPLE_CREATED_AT_ASC
  TOP_ARTISTS_VARIANCE_SAMPLE_CREATED_AT_DESC
  TOP_ARTISTS_VARIANCE_SAMPLE_UPDATED_AT_ASC
  TOP_ARTISTS_VARIANCE_SAMPLE_UPDATED_AT_DESC
  TOP_ARTISTS_VARIANCE_POPULATION_ID_ASC
  TOP_ARTISTS_VARIANCE_POPULATION_ID_DESC
  TOP_ARTISTS_VARIANCE_POPULATION_USER_ID_ASC
  TOP_ARTISTS_VARIANCE_POPULATION_USER_ID_DESC
  TOP_ARTISTS_VARIANCE_POPULATION_CREATED_AT_ASC
  TOP_ARTISTS_VARIANCE_POPULATION_CREATED_AT_DESC
  TOP_ARTISTS_VARIANCE_POPULATION_UPDATED_AT_ASC
  TOP_ARTISTS_VARIANCE_POPULATION_UPDATED_AT_DESC
  RECENT_LISTENS_COUNT_ASC
  RECENT_LISTENS_COUNT_DESC
  RECENT_LISTENS_SUM_ID_ASC
  RECENT_LISTENS_SUM_ID_DESC
  RECENT_LISTENS_SUM_SONG_ID_ASC
  RECENT_LISTENS_SUM_SONG_ID_DESC
  RECENT_LISTENS_SUM_USER_ID_ASC
  RECENT_LISTENS_SUM_USER_ID_DESC
  RECENT_LISTENS_SUM_PLAYED_AT_ASC
  RECENT_LISTENS_SUM_PLAYED_AT_DESC
  RECENT_LISTENS_SUM_CREATED_AT_ASC
  RECENT_LISTENS_SUM_CREATED_AT_DESC
  RECENT_LISTENS_SUM_UPDATED_AT_ASC
  RECENT_LISTENS_SUM_UPDATED_AT_DESC
  RECENT_LISTENS_DISTINCT_COUNT_ID_ASC
  RECENT_LISTENS_DISTINCT_COUNT_ID_DESC
  RECENT_LISTENS_DISTINCT_COUNT_SONG_ID_ASC
  RECENT_LISTENS_DISTINCT_COUNT_SONG_ID_DESC
  RECENT_LISTENS_DISTINCT_COUNT_USER_ID_ASC
  RECENT_LISTENS_DISTINCT_COUNT_USER_ID_DESC
  RECENT_LISTENS_DISTINCT_COUNT_PLAYED_AT_ASC
  RECENT_LISTENS_DISTINCT_COUNT_PLAYED_AT_DESC
  RECENT_LISTENS_DISTINCT_COUNT_CREATED_AT_ASC
  RECENT_LISTENS_DISTINCT_COUNT_CREATED_AT_DESC
  RECENT_LISTENS_DISTINCT_COUNT_UPDATED_AT_ASC
  RECENT_LISTENS_DISTINCT_COUNT_UPDATED_AT_DESC
  RECENT_LISTENS_MIN_ID_ASC
  RECENT_LISTENS_MIN_ID_DESC
  RECENT_LISTENS_MIN_SONG_ID_ASC
  RECENT_LISTENS_MIN_SONG_ID_DESC
  RECENT_LISTENS_MIN_USER_ID_ASC
  RECENT_LISTENS_MIN_USER_ID_DESC
  RECENT_LISTENS_MIN_PLAYED_AT_ASC
  RECENT_LISTENS_MIN_PLAYED_AT_DESC
  RECENT_LISTENS_MIN_CREATED_AT_ASC
  RECENT_LISTENS_MIN_CREATED_AT_DESC
  RECENT_LISTENS_MIN_UPDATED_AT_ASC
  RECENT_LISTENS_MIN_UPDATED_AT_DESC
  RECENT_LISTENS_MAX_ID_ASC
  RECENT_LISTENS_MAX_ID_DESC
  RECENT_LISTENS_MAX_SONG_ID_ASC
  RECENT_LISTENS_MAX_SONG_ID_DESC
  RECENT_LISTENS_MAX_USER_ID_ASC
  RECENT_LISTENS_MAX_USER_ID_DESC
  RECENT_LISTENS_MAX_PLAYED_AT_ASC
  RECENT_LISTENS_MAX_PLAYED_AT_DESC
  RECENT_LISTENS_MAX_CREATED_AT_ASC
  RECENT_LISTENS_MAX_CREATED_AT_DESC
  RECENT_LISTENS_MAX_UPDATED_AT_ASC
  RECENT_LISTENS_MAX_UPDATED_AT_DESC
  RECENT_LISTENS_AVERAGE_ID_ASC
  RECENT_LISTENS_AVERAGE_ID_DESC
  RECENT_LISTENS_AVERAGE_SONG_ID_ASC
  RECENT_LISTENS_AVERAGE_SONG_ID_DESC
  RECENT_LISTENS_AVERAGE_USER_ID_ASC
  RECENT_LISTENS_AVERAGE_USER_ID_DESC
  RECENT_LISTENS_AVERAGE_PLAYED_AT_ASC
  RECENT_LISTENS_AVERAGE_PLAYED_AT_DESC
  RECENT_LISTENS_AVERAGE_CREATED_AT_ASC
  RECENT_LISTENS_AVERAGE_CREATED_AT_DESC
  RECENT_LISTENS_AVERAGE_UPDATED_AT_ASC
  RECENT_LISTENS_AVERAGE_UPDATED_AT_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_ID_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_ID_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_SONG_ID_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_SONG_ID_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_USER_ID_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_USER_ID_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_PLAYED_AT_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_PLAYED_AT_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_CREATED_AT_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_CREATED_AT_DESC
  RECENT_LISTENS_STDDEV_SAMPLE_UPDATED_AT_ASC
  RECENT_LISTENS_STDDEV_SAMPLE_UPDATED_AT_DESC
  RECENT_LISTENS_STDDEV_POPULATION_ID_ASC
  RECENT_LISTENS_STDDEV_POPULATION_ID_DESC
  RECENT_LISTENS_STDDEV_POPULATION_SONG_ID_ASC
  RECENT_LISTENS_STDDEV_POPULATION_SONG_ID_DESC
  RECENT_LISTENS_STDDEV_POPULATION_USER_ID_ASC
  RECENT_LISTENS_STDDEV_POPULATION_USER_ID_DESC
  RECENT_LISTENS_STDDEV_POPULATION_PLAYED_AT_ASC
  RECENT_LISTENS_STDDEV_POPULATION_PLAYED_AT_DESC
  RECENT_LISTENS_STDDEV_POPULATION_CREATED_AT_ASC
  RECENT_LISTENS_STDDEV_POPULATION_CREATED_AT_DESC
  RECENT_LISTENS_STDDEV_POPULATION_UPDATED_AT_ASC
  RECENT_LISTENS_STDDEV_POPULATION_UPDATED_AT_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_ID_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_ID_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_SONG_ID_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_SONG_ID_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_USER_ID_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_USER_ID_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_PLAYED_AT_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_PLAYED_AT_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_CREATED_AT_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_CREATED_AT_DESC
  RECENT_LISTENS_VARIANCE_SAMPLE_UPDATED_AT_ASC
  RECENT_LISTENS_VARIANCE_SAMPLE_UPDATED_AT_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_ID_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_ID_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_SONG_ID_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_SONG_ID_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_USER_ID_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_USER_ID_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_PLAYED_AT_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_PLAYED_AT_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_CREATED_AT_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_CREATED_AT_DESC
  RECENT_LISTENS_VARIANCE_POPULATION_UPDATED_AT_ASC
  RECENT_LISTENS_VARIANCE_POPULATION_UPDATED_AT_DESC
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `spotifyId` field."""
  spotifyId: String

  """Checks for equality with the object’s `username` field."""
  username: String

  """Checks for equality with the object’s `password` field."""
  password: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `Album`."""
  createAlbum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAlbumInput!
  ): CreateAlbumPayload

  """Creates a single `Artist`."""
  createArtist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateArtistInput!
  ): CreateArtistPayload

  """Creates a single `RecentListen`."""
  createRecentListen(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateRecentListenInput!
  ): CreateRecentListenPayload

  """Creates a single `Song`."""
  createSong(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSongInput!
  ): CreateSongPayload

  """Creates a single `Thumbnail`."""
  createThumbnail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateThumbnailInput!
  ): CreateThumbnailPayload

  """Creates a single `TopArtistDatum`."""
  createTopArtistDatum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTopArtistDatumInput!
  ): CreateTopArtistDatumPayload

  """Creates a single `TopArtist`."""
  createTopArtist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTopArtistInput!
  ): CreateTopArtistPayload

  """Creates a single `TopSongDatum`."""
  createTopSongDatum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTopSongDatumInput!
  ): CreateTopSongDatumPayload

  """Creates a single `TopSong`."""
  createTopSong(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTopSongInput!
  ): CreateTopSongPayload

  """Creates a single `User`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Updates a single `Album` using its globally unique id and a patch."""
  updateAlbumByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAlbumByNodeIdInput!
  ): UpdateAlbumPayload

  """Updates a single `Album` using a unique key and a patch."""
  updateAlbum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAlbumInput!
  ): UpdateAlbumPayload

  """Updates a single `Artist` using its globally unique id and a patch."""
  updateArtistByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateArtistByNodeIdInput!
  ): UpdateArtistPayload

  """Updates a single `Artist` using a unique key and a patch."""
  updateArtist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateArtistInput!
  ): UpdateArtistPayload

  """
  Updates a single `RecentListen` using its globally unique id and a patch.
  """
  updateRecentListenByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRecentListenByNodeIdInput!
  ): UpdateRecentListenPayload

  """Updates a single `RecentListen` using a unique key and a patch."""
  updateRecentListen(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRecentListenInput!
  ): UpdateRecentListenPayload

  """Updates a single `Song` using its globally unique id and a patch."""
  updateSongByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSongByNodeIdInput!
  ): UpdateSongPayload

  """Updates a single `Song` using a unique key and a patch."""
  updateSong(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSongInput!
  ): UpdateSongPayload

  """Updates a single `Thumbnail` using its globally unique id and a patch."""
  updateThumbnailByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateThumbnailByNodeIdInput!
  ): UpdateThumbnailPayload

  """Updates a single `Thumbnail` using a unique key and a patch."""
  updateThumbnail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateThumbnailInput!
  ): UpdateThumbnailPayload

  """
  Updates a single `TopArtistDatum` using its globally unique id and a patch.
  """
  updateTopArtistDatumByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTopArtistDatumByNodeIdInput!
  ): UpdateTopArtistDatumPayload

  """Updates a single `TopArtistDatum` using a unique key and a patch."""
  updateTopArtistDatum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTopArtistDatumInput!
  ): UpdateTopArtistDatumPayload

  """Updates a single `TopArtist` using its globally unique id and a patch."""
  updateTopArtistByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTopArtistByNodeIdInput!
  ): UpdateTopArtistPayload

  """Updates a single `TopArtist` using a unique key and a patch."""
  updateTopArtist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTopArtistInput!
  ): UpdateTopArtistPayload

  """
  Updates a single `TopSongDatum` using its globally unique id and a patch.
  """
  updateTopSongDatumByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTopSongDatumByNodeIdInput!
  ): UpdateTopSongDatumPayload

  """Updates a single `TopSongDatum` using a unique key and a patch."""
  updateTopSongDatum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTopSongDatumInput!
  ): UpdateTopSongDatumPayload

  """Updates a single `TopSong` using its globally unique id and a patch."""
  updateTopSongByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTopSongByNodeIdInput!
  ): UpdateTopSongPayload

  """Updates a single `TopSong` using a unique key and a patch."""
  updateTopSong(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTopSongInput!
  ): UpdateTopSongPayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByNodeIdInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Deletes a single `Album` using its globally unique id."""
  deleteAlbumByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAlbumByNodeIdInput!
  ): DeleteAlbumPayload

  """Deletes a single `Album` using a unique key."""
  deleteAlbum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAlbumInput!
  ): DeleteAlbumPayload

  """Deletes a single `Artist` using its globally unique id."""
  deleteArtistByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteArtistByNodeIdInput!
  ): DeleteArtistPayload

  """Deletes a single `Artist` using a unique key."""
  deleteArtist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteArtistInput!
  ): DeleteArtistPayload

  """Deletes a single `RecentListen` using its globally unique id."""
  deleteRecentListenByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRecentListenByNodeIdInput!
  ): DeleteRecentListenPayload

  """Deletes a single `RecentListen` using a unique key."""
  deleteRecentListen(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRecentListenInput!
  ): DeleteRecentListenPayload

  """Deletes a single `Song` using its globally unique id."""
  deleteSongByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSongByNodeIdInput!
  ): DeleteSongPayload

  """Deletes a single `Song` using a unique key."""
  deleteSong(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSongInput!
  ): DeleteSongPayload

  """Deletes a single `Thumbnail` using its globally unique id."""
  deleteThumbnailByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteThumbnailByNodeIdInput!
  ): DeleteThumbnailPayload

  """Deletes a single `Thumbnail` using a unique key."""
  deleteThumbnail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteThumbnailInput!
  ): DeleteThumbnailPayload

  """Deletes a single `TopArtistDatum` using its globally unique id."""
  deleteTopArtistDatumByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTopArtistDatumByNodeIdInput!
  ): DeleteTopArtistDatumPayload

  """Deletes a single `TopArtistDatum` using a unique key."""
  deleteTopArtistDatum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTopArtistDatumInput!
  ): DeleteTopArtistDatumPayload

  """Deletes a single `TopArtist` using its globally unique id."""
  deleteTopArtistByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTopArtistByNodeIdInput!
  ): DeleteTopArtistPayload

  """Deletes a single `TopArtist` using a unique key."""
  deleteTopArtist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTopArtistInput!
  ): DeleteTopArtistPayload

  """Deletes a single `TopSongDatum` using its globally unique id."""
  deleteTopSongDatumByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTopSongDatumByNodeIdInput!
  ): DeleteTopSongDatumPayload

  """Deletes a single `TopSongDatum` using a unique key."""
  deleteTopSongDatum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTopSongDatumInput!
  ): DeleteTopSongDatumPayload

  """Deletes a single `TopSong` using its globally unique id."""
  deleteTopSongByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTopSongByNodeIdInput!
  ): DeleteTopSongPayload

  """Deletes a single `TopSong` using a unique key."""
  deleteTopSong(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTopSongInput!
  ): DeleteTopSongPayload

  """Deletes a single `User` using its globally unique id."""
  deleteUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserByNodeIdInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload
}

"""The output of our create `Album` mutation."""
type CreateAlbumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Album` that was created by this mutation."""
  album: Album

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Artist` that is related to this `Album`."""
  artist: Artist

  """An edge for our `Album`. May be used by Relay 1."""
  albumEdge(
    """The method to use when ordering `Album`."""
    orderBy: [AlbumsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AlbumsEdge
}

"""All input for the create `Album` mutation."""
input CreateAlbumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Album` to be created by this mutation."""
  album: AlbumInput!
}

"""An input for mutations affecting `Album`"""
input AlbumInput {
  id: String!
  name: String
  spotifyId: String
  artistId: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `Artist` mutation."""
type CreateArtistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Artist` that was created by this mutation."""
  artist: Artist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Artist`. May be used by Relay 1."""
  artistEdge(
    """The method to use when ordering `Artist`."""
    orderBy: [ArtistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArtistsEdge
}

"""All input for the create `Artist` mutation."""
input CreateArtistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Artist` to be created by this mutation."""
  artist: ArtistInput!
}

"""An input for mutations affecting `Artist`"""
input ArtistInput {
  id: String!
  name: String
  spotifyId: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `RecentListen` mutation."""
type CreateRecentListenPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `RecentListen` that was created by this mutation."""
  recentListen: RecentListen

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Song` that is related to this `RecentListen`."""
  song: Song

  """Reads a single `User` that is related to this `RecentListen`."""
  user: User

  """An edge for our `RecentListen`. May be used by Relay 1."""
  recentListenEdge(
    """The method to use when ordering `RecentListen`."""
    orderBy: [RecentListensOrderBy!] = [PRIMARY_KEY_ASC]
  ): RecentListensEdge
}

"""All input for the create `RecentListen` mutation."""
input CreateRecentListenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `RecentListen` to be created by this mutation."""
  recentListen: RecentListenInput!
}

"""An input for mutations affecting `RecentListen`"""
input RecentListenInput {
  id: String!
  songId: String
  userId: String
  playedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `Song` mutation."""
type CreateSongPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Song` that was created by this mutation."""
  song: Song

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Album` that is related to this `Song`."""
  album: Album

  """Reads a single `Artist` that is related to this `Song`."""
  artist: Artist

  """An edge for our `Song`. May be used by Relay 1."""
  songEdge(
    """The method to use when ordering `Song`."""
    orderBy: [SongsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SongsEdge
}

"""All input for the create `Song` mutation."""
input CreateSongInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Song` to be created by this mutation."""
  song: SongInput!
}

"""An input for mutations affecting `Song`"""
input SongInput {
  id: String!
  spotifyId: String
  albumId: String
  artistId: String
  name: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `Thumbnail` mutation."""
type CreateThumbnailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Thumbnail` that was created by this mutation."""
  thumbnail: Thumbnail

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Thumbnail`. May be used by Relay 1."""
  thumbnailEdge(
    """The method to use when ordering `Thumbnail`."""
    orderBy: [ThumbnailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ThumbnailsEdge
}

"""All input for the create `Thumbnail` mutation."""
input CreateThumbnailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Thumbnail` to be created by this mutation."""
  thumbnail: ThumbnailInput!
}

"""An input for mutations affecting `Thumbnail`"""
input ThumbnailInput {
  id: String!

  """12"""
  entityType: String
  entityId: String
  width: Int
  height: Int
  url: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `TopArtistDatum` mutation."""
type CreateTopArtistDatumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopArtistDatum` that was created by this mutation."""
  topArtistDatum: TopArtistDatum

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Artist` that is related to this `TopArtistDatum`."""
  artist: Artist

  """Reads a single `TopArtist` that is related to this `TopArtistDatum`."""
  topArtist: TopArtist

  """An edge for our `TopArtistDatum`. May be used by Relay 1."""
  topArtistDatumEdge(
    """The method to use when ordering `TopArtistDatum`."""
    orderBy: [TopArtistDataOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopArtistDataEdge
}

"""All input for the create `TopArtistDatum` mutation."""
input CreateTopArtistDatumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TopArtistDatum` to be created by this mutation."""
  topArtistDatum: TopArtistDatumInput!
}

"""An input for mutations affecting `TopArtistDatum`"""
input TopArtistDatumInput {
  id: String!
  artistId: String
  topArtistId: String
  timePeriod: String
  order: Int
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `TopArtist` mutation."""
type CreateTopArtistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopArtist` that was created by this mutation."""
  topArtist: TopArtist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `TopArtist`."""
  user: User

  """An edge for our `TopArtist`. May be used by Relay 1."""
  topArtistEdge(
    """The method to use when ordering `TopArtist`."""
    orderBy: [TopArtistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopArtistsEdge
}

"""All input for the create `TopArtist` mutation."""
input CreateTopArtistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TopArtist` to be created by this mutation."""
  topArtist: TopArtistInput!
}

"""An input for mutations affecting `TopArtist`"""
input TopArtistInput {
  id: String!
  userId: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `TopSongDatum` mutation."""
type CreateTopSongDatumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopSongDatum` that was created by this mutation."""
  topSongDatum: TopSongDatum

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Song` that is related to this `TopSongDatum`."""
  song: Song

  """Reads a single `TopSong` that is related to this `TopSongDatum`."""
  topSong: TopSong

  """An edge for our `TopSongDatum`. May be used by Relay 1."""
  topSongDatumEdge(
    """The method to use when ordering `TopSongDatum`."""
    orderBy: [TopSongDataOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopSongDataEdge
}

"""All input for the create `TopSongDatum` mutation."""
input CreateTopSongDatumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TopSongDatum` to be created by this mutation."""
  topSongDatum: TopSongDatumInput!
}

"""An input for mutations affecting `TopSongDatum`"""
input TopSongDatumInput {
  id: String!
  songId: String
  topSongId: String
  order: Int
  timePeriod: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `TopSong` mutation."""
type CreateTopSongPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopSong` that was created by this mutation."""
  topSong: TopSong

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `TopSong`."""
  user: User

  """An edge for our `TopSong`. May be used by Relay 1."""
  topSongEdge(
    """The method to use when ordering `TopSong`."""
    orderBy: [TopSongsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopSongsEdge
}

"""All input for the create `TopSong` mutation."""
input CreateTopSongInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TopSong` to be created by this mutation."""
  topSong: TopSongInput!
}

"""An input for mutations affecting `TopSong`"""
input TopSongInput {
  id: String!
  userId: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting `User`"""
input UserInput {
  id: String!
  spotifyId: String
  username: String
  password: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update `Album` mutation."""
type UpdateAlbumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Album` that was updated by this mutation."""
  album: Album

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Artist` that is related to this `Album`."""
  artist: Artist

  """An edge for our `Album`. May be used by Relay 1."""
  albumEdge(
    """The method to use when ordering `Album`."""
    orderBy: [AlbumsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AlbumsEdge
}

"""All input for the `updateAlbumByNodeId` mutation."""
input UpdateAlbumByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Album` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Album` being updated.
  """
  patch: AlbumPatch!
}

"""
Represents an update to a `Album`. Fields that are set will be updated.
"""
input AlbumPatch {
  id: String
  name: String
  spotifyId: String
  artistId: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateAlbum` mutation."""
input UpdateAlbumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Album` being updated.
  """
  patch: AlbumPatch!
  id: String!
}

"""The output of our update `Artist` mutation."""
type UpdateArtistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Artist` that was updated by this mutation."""
  artist: Artist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Artist`. May be used by Relay 1."""
  artistEdge(
    """The method to use when ordering `Artist`."""
    orderBy: [ArtistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArtistsEdge
}

"""All input for the `updateArtistByNodeId` mutation."""
input UpdateArtistByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Artist` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Artist` being updated.
  """
  patch: ArtistPatch!
}

"""
Represents an update to a `Artist`. Fields that are set will be updated.
"""
input ArtistPatch {
  id: String
  name: String
  spotifyId: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateArtist` mutation."""
input UpdateArtistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Artist` being updated.
  """
  patch: ArtistPatch!
  id: String!
}

"""The output of our update `RecentListen` mutation."""
type UpdateRecentListenPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `RecentListen` that was updated by this mutation."""
  recentListen: RecentListen

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Song` that is related to this `RecentListen`."""
  song: Song

  """Reads a single `User` that is related to this `RecentListen`."""
  user: User

  """An edge for our `RecentListen`. May be used by Relay 1."""
  recentListenEdge(
    """The method to use when ordering `RecentListen`."""
    orderBy: [RecentListensOrderBy!] = [PRIMARY_KEY_ASC]
  ): RecentListensEdge
}

"""All input for the `updateRecentListenByNodeId` mutation."""
input UpdateRecentListenByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `RecentListen` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `RecentListen` being updated.
  """
  patch: RecentListenPatch!
}

"""
Represents an update to a `RecentListen`. Fields that are set will be updated.
"""
input RecentListenPatch {
  id: String
  songId: String
  userId: String
  playedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateRecentListen` mutation."""
input UpdateRecentListenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `RecentListen` being updated.
  """
  patch: RecentListenPatch!
  id: String!
}

"""The output of our update `Song` mutation."""
type UpdateSongPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Song` that was updated by this mutation."""
  song: Song

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Album` that is related to this `Song`."""
  album: Album

  """Reads a single `Artist` that is related to this `Song`."""
  artist: Artist

  """An edge for our `Song`. May be used by Relay 1."""
  songEdge(
    """The method to use when ordering `Song`."""
    orderBy: [SongsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SongsEdge
}

"""All input for the `updateSongByNodeId` mutation."""
input UpdateSongByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Song` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Song` being updated.
  """
  patch: SongPatch!
}

"""Represents an update to a `Song`. Fields that are set will be updated."""
input SongPatch {
  id: String
  spotifyId: String
  albumId: String
  artistId: String
  name: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateSong` mutation."""
input UpdateSongInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Song` being updated.
  """
  patch: SongPatch!
  id: String!
}

"""The output of our update `Thumbnail` mutation."""
type UpdateThumbnailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Thumbnail` that was updated by this mutation."""
  thumbnail: Thumbnail

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Thumbnail`. May be used by Relay 1."""
  thumbnailEdge(
    """The method to use when ordering `Thumbnail`."""
    orderBy: [ThumbnailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ThumbnailsEdge
}

"""All input for the `updateThumbnailByNodeId` mutation."""
input UpdateThumbnailByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Thumbnail` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Thumbnail` being updated.
  """
  patch: ThumbnailPatch!
}

"""
Represents an update to a `Thumbnail`. Fields that are set will be updated.
"""
input ThumbnailPatch {
  id: String

  """12"""
  entityType: String
  entityId: String
  width: Int
  height: Int
  url: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateThumbnail` mutation."""
input UpdateThumbnailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Thumbnail` being updated.
  """
  patch: ThumbnailPatch!
  id: String!
}

"""The output of our update `TopArtistDatum` mutation."""
type UpdateTopArtistDatumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopArtistDatum` that was updated by this mutation."""
  topArtistDatum: TopArtistDatum

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Artist` that is related to this `TopArtistDatum`."""
  artist: Artist

  """Reads a single `TopArtist` that is related to this `TopArtistDatum`."""
  topArtist: TopArtist

  """An edge for our `TopArtistDatum`. May be used by Relay 1."""
  topArtistDatumEdge(
    """The method to use when ordering `TopArtistDatum`."""
    orderBy: [TopArtistDataOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopArtistDataEdge
}

"""All input for the `updateTopArtistDatumByNodeId` mutation."""
input UpdateTopArtistDatumByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TopArtistDatum` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TopArtistDatum` being updated.
  """
  patch: TopArtistDatumPatch!
}

"""
Represents an update to a `TopArtistDatum`. Fields that are set will be updated.
"""
input TopArtistDatumPatch {
  id: String
  artistId: String
  topArtistId: String
  timePeriod: String
  order: Int
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateTopArtistDatum` mutation."""
input UpdateTopArtistDatumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TopArtistDatum` being updated.
  """
  patch: TopArtistDatumPatch!
  id: String!
}

"""The output of our update `TopArtist` mutation."""
type UpdateTopArtistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopArtist` that was updated by this mutation."""
  topArtist: TopArtist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `TopArtist`."""
  user: User

  """An edge for our `TopArtist`. May be used by Relay 1."""
  topArtistEdge(
    """The method to use when ordering `TopArtist`."""
    orderBy: [TopArtistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopArtistsEdge
}

"""All input for the `updateTopArtistByNodeId` mutation."""
input UpdateTopArtistByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TopArtist` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TopArtist` being updated.
  """
  patch: TopArtistPatch!
}

"""
Represents an update to a `TopArtist`. Fields that are set will be updated.
"""
input TopArtistPatch {
  id: String
  userId: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateTopArtist` mutation."""
input UpdateTopArtistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TopArtist` being updated.
  """
  patch: TopArtistPatch!
  id: String!
}

"""The output of our update `TopSongDatum` mutation."""
type UpdateTopSongDatumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopSongDatum` that was updated by this mutation."""
  topSongDatum: TopSongDatum

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Song` that is related to this `TopSongDatum`."""
  song: Song

  """Reads a single `TopSong` that is related to this `TopSongDatum`."""
  topSong: TopSong

  """An edge for our `TopSongDatum`. May be used by Relay 1."""
  topSongDatumEdge(
    """The method to use when ordering `TopSongDatum`."""
    orderBy: [TopSongDataOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopSongDataEdge
}

"""All input for the `updateTopSongDatumByNodeId` mutation."""
input UpdateTopSongDatumByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TopSongDatum` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TopSongDatum` being updated.
  """
  patch: TopSongDatumPatch!
}

"""
Represents an update to a `TopSongDatum`. Fields that are set will be updated.
"""
input TopSongDatumPatch {
  id: String
  songId: String
  topSongId: String
  order: Int
  timePeriod: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateTopSongDatum` mutation."""
input UpdateTopSongDatumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TopSongDatum` being updated.
  """
  patch: TopSongDatumPatch!
  id: String!
}

"""The output of our update `TopSong` mutation."""
type UpdateTopSongPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopSong` that was updated by this mutation."""
  topSong: TopSong

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `TopSong`."""
  user: User

  """An edge for our `TopSong`. May be used by Relay 1."""
  topSongEdge(
    """The method to use when ordering `TopSong`."""
    orderBy: [TopSongsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopSongsEdge
}

"""All input for the `updateTopSongByNodeId` mutation."""
input UpdateTopSongByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TopSong` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TopSong` being updated.
  """
  patch: TopSongPatch!
}

"""
Represents an update to a `TopSong`. Fields that are set will be updated.
"""
input TopSongPatch {
  id: String
  userId: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateTopSong` mutation."""
input UpdateTopSongInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TopSong` being updated.
  """
  patch: TopSongPatch!
  id: String!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `updateUserByNodeId` mutation."""
input UpdateUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  id: String
  spotifyId: String
  username: String
  password: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
  id: String!
}

"""The output of our delete `Album` mutation."""
type DeleteAlbumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Album` that was deleted by this mutation."""
  album: Album
  deletedAlbumNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Artist` that is related to this `Album`."""
  artist: Artist

  """An edge for our `Album`. May be used by Relay 1."""
  albumEdge(
    """The method to use when ordering `Album`."""
    orderBy: [AlbumsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AlbumsEdge
}

"""All input for the `deleteAlbumByNodeId` mutation."""
input DeleteAlbumByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Album` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAlbum` mutation."""
input DeleteAlbumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `Artist` mutation."""
type DeleteArtistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Artist` that was deleted by this mutation."""
  artist: Artist
  deletedArtistNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Artist`. May be used by Relay 1."""
  artistEdge(
    """The method to use when ordering `Artist`."""
    orderBy: [ArtistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArtistsEdge
}

"""All input for the `deleteArtistByNodeId` mutation."""
input DeleteArtistByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Artist` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteArtist` mutation."""
input DeleteArtistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `RecentListen` mutation."""
type DeleteRecentListenPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `RecentListen` that was deleted by this mutation."""
  recentListen: RecentListen
  deletedRecentListenNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Song` that is related to this `RecentListen`."""
  song: Song

  """Reads a single `User` that is related to this `RecentListen`."""
  user: User

  """An edge for our `RecentListen`. May be used by Relay 1."""
  recentListenEdge(
    """The method to use when ordering `RecentListen`."""
    orderBy: [RecentListensOrderBy!] = [PRIMARY_KEY_ASC]
  ): RecentListensEdge
}

"""All input for the `deleteRecentListenByNodeId` mutation."""
input DeleteRecentListenByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `RecentListen` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteRecentListen` mutation."""
input DeleteRecentListenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `Song` mutation."""
type DeleteSongPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Song` that was deleted by this mutation."""
  song: Song
  deletedSongNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Album` that is related to this `Song`."""
  album: Album

  """Reads a single `Artist` that is related to this `Song`."""
  artist: Artist

  """An edge for our `Song`. May be used by Relay 1."""
  songEdge(
    """The method to use when ordering `Song`."""
    orderBy: [SongsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SongsEdge
}

"""All input for the `deleteSongByNodeId` mutation."""
input DeleteSongByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Song` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSong` mutation."""
input DeleteSongInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `Thumbnail` mutation."""
type DeleteThumbnailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Thumbnail` that was deleted by this mutation."""
  thumbnail: Thumbnail
  deletedThumbnailNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Thumbnail`. May be used by Relay 1."""
  thumbnailEdge(
    """The method to use when ordering `Thumbnail`."""
    orderBy: [ThumbnailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ThumbnailsEdge
}

"""All input for the `deleteThumbnailByNodeId` mutation."""
input DeleteThumbnailByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Thumbnail` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteThumbnail` mutation."""
input DeleteThumbnailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `TopArtistDatum` mutation."""
type DeleteTopArtistDatumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopArtistDatum` that was deleted by this mutation."""
  topArtistDatum: TopArtistDatum
  deletedTopArtistDatumNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Artist` that is related to this `TopArtistDatum`."""
  artist: Artist

  """Reads a single `TopArtist` that is related to this `TopArtistDatum`."""
  topArtist: TopArtist

  """An edge for our `TopArtistDatum`. May be used by Relay 1."""
  topArtistDatumEdge(
    """The method to use when ordering `TopArtistDatum`."""
    orderBy: [TopArtistDataOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopArtistDataEdge
}

"""All input for the `deleteTopArtistDatumByNodeId` mutation."""
input DeleteTopArtistDatumByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TopArtistDatum` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTopArtistDatum` mutation."""
input DeleteTopArtistDatumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `TopArtist` mutation."""
type DeleteTopArtistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopArtist` that was deleted by this mutation."""
  topArtist: TopArtist
  deletedTopArtistNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `TopArtist`."""
  user: User

  """An edge for our `TopArtist`. May be used by Relay 1."""
  topArtistEdge(
    """The method to use when ordering `TopArtist`."""
    orderBy: [TopArtistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopArtistsEdge
}

"""All input for the `deleteTopArtistByNodeId` mutation."""
input DeleteTopArtistByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TopArtist` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTopArtist` mutation."""
input DeleteTopArtistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `TopSongDatum` mutation."""
type DeleteTopSongDatumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopSongDatum` that was deleted by this mutation."""
  topSongDatum: TopSongDatum
  deletedTopSongDatumNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Song` that is related to this `TopSongDatum`."""
  song: Song

  """Reads a single `TopSong` that is related to this `TopSongDatum`."""
  topSong: TopSong

  """An edge for our `TopSongDatum`. May be used by Relay 1."""
  topSongDatumEdge(
    """The method to use when ordering `TopSongDatum`."""
    orderBy: [TopSongDataOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopSongDataEdge
}

"""All input for the `deleteTopSongDatumByNodeId` mutation."""
input DeleteTopSongDatumByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TopSongDatum` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTopSongDatum` mutation."""
input DeleteTopSongDatumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `TopSong` mutation."""
type DeleteTopSongPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TopSong` that was deleted by this mutation."""
  topSong: TopSong
  deletedTopSongNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `TopSong`."""
  user: User

  """An edge for our `TopSong`. May be used by Relay 1."""
  topSongEdge(
    """The method to use when ordering `TopSong`."""
    orderBy: [TopSongsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TopSongsEdge
}

"""All input for the `deleteTopSongByNodeId` mutation."""
input DeleteTopSongByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TopSong` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTopSong` mutation."""
input DeleteTopSongInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `deleteUserByNodeId` mutation."""
input DeleteUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}
